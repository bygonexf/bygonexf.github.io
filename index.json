[{"categories":null,"contents":"博客什么的，像对着充满未知的可能性的黑洞在倾诉在记录在整理自己。\n他迫切地需要表达自己，复述他读过的东西，表达自己观察到的事物。这是他整理自己的思想的方式——谈话，谈话，谈话，但我想这也是他寂寞的一种表现。我觉得自己和他很像，这让我觉得很自豪，我和他一样都想塑造自己作为读书人的形象，并且让别人承认这一点，就像在说：这就是我所知道的事情，这就是我要成为的人。\n我们的卑劣和我们的坦诚在这点上和莱农和尼诺也是类似的吧。\n我需要记录。记录需要假想观测者。所以感谢路过的你提供的可能性。\n如果我说自己的天赋在于感受，也太狡猾了。能感受不能输出，怎么看也像是程度不够的借口。我想记录，各个方面的，以各种形式。没有超8mm胶片，有文字也不错。\n最后留个邮箱：faye#stu.pku.edu.cn (请将#替换为@)\n","date":"2023-01-08T00:00:00Z","permalink":"https://imfaye.me/about/","section":"","tags":null,"title":"关于我"},{"categories":["有情笔记"],"contents":"引子 生成模型 能从可学习的概率分布中采样得到样本的模型。\n在一些生成模型中，样本通过将随机的隐层变量送入网络生成得到。\n自编码器 AE 自编码器通过学习从输入到隐层和从隐层到输出的映射来重建信号/图像。\n目标：$X\u0026rsquo; = D_\\theta(E_\\phi(X)) \\approx X$\n$\\mathop{min}\\limits_{\\theta, \\phi} \\sum\\limits_{i=1}^n||D_\\theta(E_\\phi(X_i))-X_i||^2$，其中 ${{X_i}}_{i=1\\cdots n}$ 为数据集。\n自编码器并不是一种生成模型，因为它并没有定义一个概率分布，无法采样。\n自编码器 → 生成模型？\n我们会有一个很自然的做生成模型的想法，那就是训练一个从低维隐层变量生成观测样本的生成模型，最大化观测数据似然。\n假设这个生成模型为 $G_{\\theta}:\\mathbb{R}^k \\rightarrow \\mathbb{R}^d$，其中 $k \u0026lt; d$，将隐层变量 $Z$ 映射为样本 $X$，那么其实在样本空间里几乎大部分区域 $p(X)=0$。\n如果我们从样本空间看，在这个高维空间只会有非常小的一个低维空间子集 $p(X)$ 是有值的，并且我们在训练的时候其实是不知道这个子集的分布的，而其余大部分区域 $p(X)=0$，也就意味着我们很难直接优化似然。\n但是有一种方法可以让我们在每一处都得到非零值，那就是在已有先验 $p(Z)$ 的条件下，定义一个有噪声的观测模型 $p_\\theta(X|Z)=\\mathcal{N}(X;G_\\theta(Z), \\eta I)$ (其中 $\\eta$ 是可调整的参数，$I$ 是单位矩阵)。\n所以 $p(X) = \\int p(Z)p(X|Z)\\mathrm{d}Z$，这个值也很难去计算，所以我们不是去优化 $p(X)$ 而是去优化 $p(X)$ 的下限（变分推断里的证据下限 ELBO，后面会证明）。\n那么这其实就是 VAE 的雏形了。\n变分自编码器 VAE 上面的图是 VAE 的整体思路，生成的部分也是也就是 decoder 的部分，我们会假设 $Z$ 服从一个简单的先验分布 $p(Z)$，这个分布可以是一个标准正态分布。通过 decoder 会得到高维图像空间的一个概率分布。\n而 encoder 端，注意 VAE 有一个很重要的想法是，我们不去直接计算难以计算的 $p_\\theta(Z|X)$，而是用另外单独学习的网络去模拟一个 $q_\\phi(Z|X)$，它其实是 $p_\\theta(Z|X)$ 的一个近似。\n$p_\\theta(X)$ 推导 再看一下 $p_\\theta(X)$ 下界的推导过程。①：因为 $p_\\theta(X)$ 是独立于 $Z$ 的，所以我们可以去计算它在 $Z$ 上的期望；②：条件概率公式；③：上下约一个 $q_\\phi(Z|X)$；④：右边的项其实就是 $q_\\phi(Z|X)$ 和 $p_\\theta(Z|X)$ 的 KL 散度，KL 散度衡量的是两个概率分布之间的相似性，两者差异越小，KL 散度越小，两分布完全一致时 KL 散度才为 0，所以因为右项恒大于等于 0，我们可以把左项视为 $log\\space p_\\theta(X)$ 的下界。之后就不直接优化 $log\\space p_\\theta(X)$，而是优化这个下界。\nVariational Lower Bound 的直观解释 再来看一下怎么理解这个变分下界，注意我们的目标是最大化这个下界。首先用条件概率公式替换一下，之后把式子拆成两部分，下面来解释一下为什么第一项是重建误差，第二项是正则项。\n之前说了我们建立了一个有噪声的观测模型 $p_\\theta(X|Z)=\\mathcal{N}(X;G_\\theta(Z), \\eta I)$ (就是 $Z$ 通过 decoder 后得到的那个高维图像空间的分布)，正态分布的公式不用说了吧，代入一下就会发现第一项是一个 L2 距离，最大化这个负的 L2 距离就是在减小重建误差，encourage $q_\\phi$ to be point mass，这句话我是这么理解的，point mass 其实是离散的概率分布，减小重建误差就是在消除我们加的这个高斯噪声，让它成为类似于我们最先讲的那个被舍弃的点到点的离散概率模型（但注意它又是连续概率，所以就是接近奇异分布？）。\n再看第二项，这一项可以写成一个 KL 散度，我们最大化负的这个 KL 散度就是在让 $q_\\phi(Z|X)$ 和 $p(Z)$ 两个概率分布尽可能接近。上一项重建损失是鼓励 $q_\\phi$ 去成为 point mass，这里则是平滑 $q_\\phi$ 去使它尽可能接近标准正态分布。\n可以看到两项之间存在相驳的张力，前一项试图让 $q_\\phi$ 成为奇异分布，后一项则试图让 $q_\\phi$ 不要成为奇异分布。可以理解为前者鼓励它准，后者鼓励它具有更强的生成性。\nVAE 架构 再来看一下 VAE 的实际架构。主要有两点值得细说。\n第一点是，如果我们对每个 $X_i$ 找最最佳的 $q_\\phi(Z|X_i)$，然后优化 $\\phi$，这样的更新代价会很大。所以我们不这么做，而是去学习一个 inference 网络预测这个 $q_\\phi(Z|X_i)$ 的均值和方差（实际上预测的是 $\\mu$ 和 $log \\space \\sigma$），这样 inference 阶段的模型参数对于所有的数据参数是共享的，就可以分摊学习和更新的成本。\n第二点是，采样的操作本身是不能反向传播的，所以采样这里用到了重参数化的技巧，也就是从 $\\mathcal{N}(0,1)$ 中采样一个 $\\varepsilon$，然后让 $Z=\\mu + \\varepsilon \\times \\sigma$，这样采样的操作就可以独立于网络之外，其他所有环节都能进行反向传播。\nStochastic Gradient Optimization of VLB Todo…\n参考 https://khoury.northeastern.edu/home/hand/teaching/cs7150-summer-2020/Variational_Autoencoders.pdf\nhttps://www.youtube.com/watch?v=c27SHdQr4lw （力荐 👍）\n","date":"2022-02-10T23:43:59Z","permalink":"https://imfaye.me/post/vae/","section":"post","tags":null,"title":"耶，VAE"},{"categories":["无情笔记"],"contents":"传统熵模型 算术编码 (Arithmetic Coding) 流程 （以静态模型举例）\n假设有一段数据需要编码，统计里面所有的字符和出现的次数。编码从初始区间 (0, 1] 开始。 在当前区间内根据各字符概率划分子区间。 读入字符，找到该字符落入的子区间，将区间更新为该子区间，并重复 2, 3 步骤 最后得到的区间 [low, high) 中任意一个小数以二进制形式输出即得到编码的数据 例子如下：\n实现细节 最后结果是一个小数，我们不能简单地用一个 double 类型去表示和计算这个小数，因为根据数据的复杂程度，这个小数可能任意长，小数点后可能会有成千上万位。\n然而，小数点后的数据前几位很有可能是在过程中是可以不断提前确定的。例如如果当前区间为 [0.14432, 0.1456)，高位的 0.14 可以提前确定，14已经可以输出了。那么小数点可以向后移动两位，区间变成 [0.432, 0.56)，在此基础上进行后面的计算。这样编码区间永远保持在一个有限的精度要求上。\n上述是基于十进制的，实际数字是用二进制表示的，当然原理是一样的，用十进制只是为了表述方便。\n静态模型 → 自适应模型 静态模型在初始时对完整的数据统计完概率分布，之后不再更新概率分布；自适应模型随着字符的输入会不断更新概率分布。\n静态模型的缺点在于：\n在压缩前对信息内字符进行统计的过程会消耗大量时间。 对较长的信息，静态模型统计出的符号概率是该符号在整个信息中的出现概率，而自适应模型可以统计出某个符号在某一局部的出现概率或某个符号相对于某一上下文的出现概率，换句话说，自适应模型得到的概率分布将有利于对信息的压缩（可以说结合上下文的自适应模型的信息熵建立在更高的概率层次上，其总熵值更小），好的基于上下文的自适应模型得到的压缩结果将远远超过静态模型。 例如一段码流，某符号在前面出现概率较大而后面概率小，甚至忽大忽小，采用自适应模型就可以更好的适应这样的变动，压缩效率会比静态模型更高。主流视频编码标准如H.264/H.265都使用自适应模型。\n算术编码 vs 哈夫曼编码 首先说结论，算术编码压缩效率更高，哈夫曼编码复杂度更低。\n这两种编码，或者说熵编码的本质是，概率越小的字符，用更多的 bit 去表示，这反映到概率区间上就是，概率小的字符所对应的区间也小，因此这个区间的上下边际值的差值越小，为了唯一确定当前这个区间，则需要更多的数字去表示它。\n哈夫曼编码由于不断地二叉，它的子区间总是 $\\frac{1}{2}$ 的幂次方。而算术编码可以做到严格按照概率的大小等比例划分子区间。所以哈夫曼编码只是算术编码一种粗略的近似。\nCABAC CABAC（Context-based Adaptive Binary Arithmetic Coding），CABAC 被视频标准H.264/H.265所采用。\nCABAC可以分为二值化、上下文建模和二进制算术编码三个步骤。\n其中上下文建模相当于把整段码流进行了再次的细分，把相同条件下的字符bin（比如块大小/亮度色度/语法元素/扫描方式/周围情况等）归属于某个context，形成一个比较独立的子队列而进行编码，其更新只与当前的状态和当前字符是否MPS有关（换句话说，只和历史该子队列编码字符和当前字符有关），而与别的子队列/字符是无关的。当然输出码字往往是根据规则而“混”在一起的。\nCABAC虽然性能很好，但也存在以下几点不足：\n复杂度过高，不易并行处理。存在块级依赖（左/上角的块没有码率估计/熵编码，后继块就无法得到更新后的状态，从而无法开始码率估计/熵编码）、Bin级依赖（同一个子队列的bin存在前后依赖性，后继的bin要等前面bin编完后才能得到更新后的上下文状态）以及编码的几个环节依赖，这些依赖性会影响编码器的并行实现。 计算精度问题。为简化计算，CABAC采用128个状态来近似，根据原来状态和当前符号性质查表得到下个状态。这个过程中会有一些精度的损失。另外，如果当一连串的MPS到来，状态到达62后就不会继续改变，只会“原地踏步”。换句话说，当概率到达0.01975时就不会随着符号继续变小，这样会影响压缩效率。 Context的设计问题。部分context利用频率很低，在测试中平均一帧都用不到几次，而有的context使用频率很高，需要进一步的优化。 区间编码 (Range Coding) 区间编码可以看为算术编码的一个变种，比算术编码压缩效率略小，但运算速度近乎是算术编码的两倍。\n区间编码在整数（任意底）空间中进行进行计算，而算术编码的区间总是以小数的形式进行迭代。其他部分都几乎一样。\n端到端熵模型 Todo\u0026hellip;\n参考 算术编码（转载加笔记）\n算数编码原理解析\n","date":"2021-12-05T13:09:24Z","permalink":"https://imfaye.me/post/entropy-coding/","section":"post","tags":["视频编码"],"title":"关于熵编码"},{"categories":["无情笔记"],"contents":"如何评价重建图像的质量：比较重建图像与原始图像的可视误差。\nMSE Mean Squared Error, 均方误差\n$MSE = \\frac{1}{N}\\sum\\limits_{i=1}^{N}(x_i-y_i)^2$\n两者越接近，MSE 越小。MSE 损失的范围为 0 到 ∞。\nPSNR Peak Signal to Noise Ratio，峰值信噪比，即峰值信号的能量与噪声的平均能量之比，通常取 log 单位为分贝。\n$PSNR = 10 log_{10}\\frac{MaxValue^2}{MSE}$\n从式子可以看出 PSNR 可以理解为 MSE 的另一种表达形式。与 MSE 相反的是，重建图像质量越好，PSNR 数值越大。\n对于图像来说，像素点数值以量化方式保存，八比特位深的情况，取值范围为 [0, 255]，$MaxValue$ 就是 255。\nSSIM MSE 与 PSNR 的问题是，在计算每个位置上的像素差异时，其结果仅与当前位置的两个像素值有关，与其它任何位置上的像素无关。这种计算差异的方式仅仅将图像看成了一个个孤立的像素点，而忽略了图像内容所包含的一些视觉特征，特别是图像的局部结构信息。而图像质量的好坏极大程度上是一个主观感受，其中结构信息对人主观感受的影响非常之大。\n而 SSIM (Structural Similarity，结构相似性) 就试图解决这个问题\nSSIM 由三部分组成：\n亮度对比 平均灰度作为亮度测量： $\\mu_x = \\frac{1}{N}\\sum\\limits_{i=1}^{N}x_i$ 亮度对比函数： $l(x,y) = \\frac{2\\mu_x\\mu_y + C_1}{\\mu_x^2+\\mu_y^2+C_1}$ 对比度对比 灰度标准差作为对比度测量： $\\sigma_x={(\\frac{1}{N-1}\\sum\\limits_{i=1}^N{(x_i-\\mu_x)}^2)}^{\\frac{1}{2}}$ 亮度对比函数： $c(x,y)=\\frac{2\\sigma_x\\sigma_y+C_2}{\\sigma_x^2+\\sigma_y^2+C_2}$ 结构对比 结构测量： $\\frac{x-\\mu_x}{\\sigma_x}$ 结构对比函数： $s(x,y) = \\frac{\\sigma_{xy}+C_3}{\\sigma_x\\sigma_y + C_3}$ SSIM 函数：\n$SSIM(x,y)={[l(x,y)]}^\\alpha \\cdot {[c(x,y)]}^\\beta \\cdot {[s(x,y)]}^\\gamma$\n$一般取 \\alpha = \\beta =\\gamma=1$\n$SSIM(x,y)=\\frac{(2\\mu_x\\mu_y+C_1)(2\\sigma_x\\sigma_y+C_2)}{(\\mu_x^2+\\mu_y^2+C_1)(\\sigma_x^2\\sigma_y^2+C_2)}$\n下图是同样 MSE 的图片，仅仅做对比拉伸（灰度拉伸，增大图像灰度级的动态范围）、均值偏移，其实不怎么影响人眼对图像的理解，而模糊和压缩痕迹则影响较大，这些情况下 SSIM 就能更好地做出判断。\nMS-SSIM SSIM 算法基于 HVS 擅长从图像中提取结构信息，并利用结构相似度计算图像的感知质量。但 SSIM 是一种单尺度算法，实际上正确的图像尺度取决于用户的观看条件，如显示设备分辨率、用户的观看距离等。\n单尺度的 SSIM 算法可能仅适用于某个特定的配置，为了解决该问题，MS-SSIM (Multi-scale structural similarity) 在 SSIM 算法的基础上提出了多尺度的结构相似性评估算法。\nMS-SSIM 算法，L 表示低通滤波器，2↓ 表示采样间隔为 2 的下采样\n原始图像的尺度为 1，最大尺度为 M，对 $scale=j$ 的尺度而言，其亮度、对比度、结构的相似性分布表示为 $l_j(x,y), c_j(x,y), s_j(x,y)$，MS-SSIM 的计算公式为：\n$MS-SSIM(x,y) = {[l_M(x,y)]}^{\\alpha M} \\cdot \\prod\\limits_{j=1}^M{[c_j(x,y)]}^{\\beta j}{[s_j(x,y)]}^{\\gamma j}$\n一般，令 $\\alpha_j = \\beta_j = \\gamma_j$，$j \\in [1, M]$，我们得到：\n$MS-SSIM(x,y) = {[l_M(x,y)]}^{\\alpha M} \\cdot \\prod\\limits_{j=1}^M{[c_j(x,y) \\cdot s_j(x,y)]}^{\\alpha j}$\n","date":"2021-12-02T23:35:47Z","permalink":"https://imfaye.me/post/image-quality-evaluation-metrics/","section":"post","tags":["视频编码"],"title":"图像质量评价指标(MSE, PSNR, MS-SSIM)"},{"categories":["无情笔记"],"contents":"概述 视频序列是位流的最高层语法结构。\n帧由一个亮度样本矩阵和两个色度样本矩阵构成。场由构成帧的三个样本矩阵中相间的行构成。奇数行构成顶场，偶数行构成底场。\n视频序列头由视频序列起码码开始，后面跟着一串编码图像数据。序列头可在位流中重复出现，称为重复序列头。使用重复序列头的主要目的是支持对视频序列的随机访问。\n一副图像可以是一帧或一场，其编码数据由图像起始码开始，到序列起始码、序列结束码或下一个图像起始码结束。\n片是图像中的矩形区域，包含若干最大编码单元在图像内的部分，片之间不应重叠。\n图像划分为最大编码单元，最大编码单元之间不应重叠，最大编码单元左上角的样本不应超出图像边界，最大编码单元右下角的样本可超出图像边界。\n最大编码单元划分为一个或多个编码单元，由编码树决定。编码单元划分为一个或多个变换块。\n码流结构及语义描述 视频序列 序列头 sequence_header\n视频序列起始码、档次标号、级别标号、知识位流标志、知识图像允许标志、知识位流重复序列头标志、逐行序列标志、场图像序列标志、水平尺寸、垂直尺寸、色度格式、样本精度、编码样本精度、宽高比、帧率代码、比特率低位、比特率高位、低延迟、时间层标识允许标志、位流缓冲区尺寸、最大解码图像缓冲区大小、参考图像队列 1 索引存在标志、参考图像队列相同标志、参考图像队列配置集数、默认活跃参考图像数、最大编码单元尺寸、最小编码单元尺寸、划分单元最大比例、编码树最大划分次数、最小四叉树尺寸、最大二叉树尺寸、最大扩展四叉树尺寸、加权量化允许标志、加权量化矩阵加载标志、二次变换允许标志、样值偏倚补偿允许标志、自适应修正滤波允许标志、仿射运动补偿允许标志、对称运动矢量差模式允许标志、脉冲编码调制模式允许标志、自适应运动矢量精度允许标志、候选历史运动信息数、帧内预测滤波允许标志、高级运动矢量表达模式允许标志、运动矢量精度扩展模式允许标志、色度两步预测模式允许标志、帧内衍生模式允许标志、衍生模式划分边长最大尺寸、基于位置的变换允许标志、图像重排序延迟、跨片环路滤波允许标志、片划分一致性标志、参考同位置片标志、统一片大小标志、片宽度、片高度\n视频编辑码和视频序列结束码\n视频编辑码 video_edit_code\n紧跟其后的第一幅 I 图像后续的 B 图像可能因缺少参考图像而不能正确解码\n视频序列结束码 video_sequence_end_code\n标识视频序列的结束。如果 POI（显示顺序索引），如果 POI 的值大于 $(2^{32}-1)$，位流中应插入一个视频序列结束码。\n参考图像队列配置集\n参考知识图像标志、知识图像索引标志、被参考的知识图像索引、参考图像数、参考图像 DOI 差值绝对值、参考图像 DOI 差值符号\n自定义加权量化矩阵\n加权量化矩阵系数\n图像 帧内预测图像头\n帧内预测图像起始码、BBV 延时、时间编码标志、时间编码、解码顺序索引、知识图像索引、时间层标识、图像输出延迟、引用参考图像队列配置集标志、引用参考图像队列配置集索引、BBV 检测次数、逐行帧标志、图像编码结构标志、顶场在先、重复首场、顶场场图像标志、固定图像量化因子、去块滤波禁用标志、去块滤波参数标志、$\\alpha$ 和 C 索引的偏移、$\\beta$ 索引的偏移、色度量化参数禁用标志、色度量化参数增量 Cb、色度量化参数增量 Cr、图像加权量化允许标志、图像加权量化数据加载索引、加权量化参数索引、加权量化矩阵模型、加权量化参数增量 1、加权量化参数增量 2、图像自适应修正滤波允许标志\n帧间预测图像头\n帧间预测图像起始码、随机访问正确解码标志、图像编码方式、活跃参考图像数重载标志、活跃参考图像数、仿射预测子块尺寸标志\n片\n片起始码、固定片量化银子标志、片量化因子、片样值偏移补偿允许标志、高级熵编码字节对齐填充位、最大编码单元量化参数增量、样值偏移补偿合并方式索引、样值偏移补偿模式、样值偏移补偿区间模式偏移绝对值、样值偏移补偿区间模式偏移值符号值、样值偏移补偿区间模式起始偏移子区间位置、样值偏移补偿区间模式起始偏移子区间位置差、样值偏移补偿模式偏移值、样值偏移补偿边缘模式类型、最大编码单元自适应修正滤波允许标志、熵编码最大编码单元填充位、片结束码\n编码树 四叉树划分标志、编码单元预测模式、二叉树扩展四叉树划分标志、二叉树扩展四叉树划分类型标志、二叉树扩展四叉树划分方向标志\n编码单元 跳过模式标志、高级运动矢量表达模式标志、仿射模式标志、直接模式标志、帧内编码单元标志、基础运动矢量索引、运动矢量偏移量索引、运动矢量方向索引、仿射运动矢量索引、衍生模式划分标志、衍生模式划分方向、水平四叉衍生模式划分标志、垂直四叉衍生模式划分标志、水平非对称衍生模式标志、仿射自适应运动矢量精度索引、自适应运动矢量精度索引、编码单元子类型索引、预测参考模式、对称运动矢量差标志、运动矢量精度扩展模式标识、帧内亮度预测模式、帧内色度预测模式、帧内预测滤波标志、L0 预测单元参考索引、L0 运动矢量水平分量差绝对值、L0 运动矢量垂直分量差绝对值、L0 运动矢量水平分量差符号值、L0 运动矢量垂直分量差符号值、仿射帧间模式L0 运动矢量水平分量差绝对值、仿射帧间模式 L0 运动矢量垂直分量差绝对值、仿射帧间模式 L0 运动矢量水平分量差符号值、仿射帧间模式 L0 运动矢量垂直分量差符号值、L1\u0026hellip;、变换块系数标志、基于位置的变换块标志、Cb 变换块编码模板、Cr 变换块编码模板、亮度变换块编码模板\n","date":"2021-04-01T17:28:29Z","permalink":"https://imfaye.me/post/avs3-bitstream/","section":"post","tags":["AVS3","视频编码"],"title":"AVS3 编码位流"},{"categories":["无情笔记"],"contents":"视频预测编码技术 预测编码是指利用已编码的一个或几个样本值，根据某种模型或方法，对当前的样本值进行预测，并对样本真实值和预测值之间的差值进行编码。\n帧内预测编码 随着离散余弦变换 (DCT) 在图像、视频编码中的广泛应用，帧内预测转为在频域进行，如相邻块 DC 系数的差分编码等。由 DCT 的性质可知，DC 系数仅能反映当前块像素值的平均大小，因此上述频域中基于 DC 系数的帧内预测无法反映出视频的纹理信息，这限制了频域帧内预测的发展。\nH.264/AVC 标准中使用基于块的空域帧内预测方法，规定了若干种预测模式，每种模式都对应一种纹理方向（DC 模式除外），当前块预测像素由其预测方向上相邻块的边界重建像素生成。该方法使得编码器能根据视频内容特征自适应地选择预测模式。\nH.264/AVC 使用拉格朗日率失真优化 (RDO) 进行模式选择。它为每一种模式计算其拉格朗日代价： $$ J = D + \\lambda \\cdot R $$ 其中，$D$ 表示当前预测模式下地失真，$R$ 表示编码当前预测模式下所有信息（如变换系数、模式细腻些、宏块划分方式等）所需的比特数。最优的预测模式不一定满足残差最小，而应指残差信号经过其他编码模块后最终的编码性能最优。\nH.264/AVC 标准及后来的 FRExt 扩展层一共规定了 3 种大小的亮度帧内预测块：4 × 4、8 × 8 以及 16 × 16。其中 4 × 4 和 8 × 8 块包含 9 种预测模式，16 × 16 块包含 4 种预测模式。色度分量的帧内预测都是基于 8 × 8 大小的块进行的，也有 4 种预测模式。\n帧间预测编码 帧间预测编码原理 目前主要的视频编码标准帧间预测部分都采样了基于块的运动补偿技术。其主要原理是为当前图像的每个像素块在之前已编码图像中寻找一个最佳匹配块，该过程被称为运动估计 (Motion Estimation, ME)。其中被参考的图像称为参考图像 (Reference Frame)，参考块到当前像素块的位移称为运动向量 (Motion Vector, MV)，当前像素块与参考块的差值称为预测残差 (Prediction Residual)。\n在 H.261 标准中，P 图像的预测方式只有前向预测。但实际场景中往往会产生不可预测的运动和遮挡，因此当前图像可能在之后的图像中更容易找到匹配块。为此，MPEG-1 标准定义了第三类图像，B 图像。为了提高运动估计精度，MPEG-1 首次采用了半像素精度的运动估计，半像素位置的参考像素值可由双线性差值方法产生。\n面向数字广播电视的标准 MPEG-2 首次支持了隔行扫描视频。一帧图像包含两个场，顶场和底场，每个帧图像的宏块需要被拆分成两个 16 × 8 的块分别进行预测。H.263 标准沿用了 MPEG-1 的双向预测和半像素精度运动估计，并进一步发展了 MPEG-2 中将一个宏块分成更小的块进行预测的思想。\nH.264/AVC 标准规定了 7 种大小的运动补偿块，一个宏块内部允许存在不同大小块的组合。此外 H.264/AVC 还使用了 1/4 精度像素运动估计、多参考图像预测、加权预测以及空域/时域 MV 预测等。\n帧间预测编码关键技术 1. 运动估计 在大多数视频序列中，相邻图像内容非常相似，不需要对每幅图像的全部信息编码，只需要将当前图像中运动物体的运动信息传给解码器。运动估计就是提取当前图像运动信息的过程。\n将图像分为不同大小的像素块，只要块大小选择合适，则各个块的运动形式可以看成是统一的，每个块的运动参数可以独立地估计，这就是常用地基于块地运动表示法。\n有几个核心问题：\n运动估计准则\n常用地匹配准则主要有最小均方误差 (MSE)、最小平均绝对误差 (MAD) 和最大匹配像素数 (MPC) 等。为了简化计算，一般使用绝对误差和 (SAD) 来代替 MAD。此外，最小变换域绝对误差和 (SATD) 也是一种性能优异的匹配准则。\n最小 SAD 准则不含乘除法，且便于硬件实现，因而使用最广泛。SAD 准则仅考虑了残差的大小，而未考虑编码运动信息所需的比特数。因此，H.264/AVC 编码器在运动估计过程中使用 RDO 来选择 MV。\n搜索算法\n常用的搜索算法有全搜索算法、二维对数搜索算法、三步搜索算法等。除全搜索算法，其余算法统称为快速算法。快速算法容易陷入局部最优点，为避免这一点，在搜索算法的每一步中尽量搜索更多的点。\n亚像素精度运动估计\n亚像素精度运动估计意味着需要对参考图像进行插值，好的插值方法能大幅改善运动补偿的性能。\n2. MV 预测 在大多数图像和视频中，一个运动物体可能会覆盖多个运动补偿块，因此空间域相邻块的运动向量具有较强的相关性。若使用相邻已编码块对当前块 MV 预测，将二者差值进行编码，则会大幅减少编码 MV 所需的比特数。同时，由于物体运动具有连续性，因此相邻图像同一位置像素块的 MV 也具有一定相关性。H.264/AVC 使用了空域和时域两种 MV 的预测方式。\nMV 空域预测\nMV 时域预测\n在 H.264/AVC 中，MV 时域预测主要针对 B Slice。主要有以下两种形式\n当 B 图像的两个 MV 都来自同一个方向时（都来自当前图像之前的参考图像或之后的），其中一个 MV 可用另一个 MV 来预测\n设两参考图像 $ref_0$ 和 $ref_1$ 与当前图像的距离分别为 $l_0$ 和 $l_1$，二者 MV 分别为 $MV_0$ 和 $MV_1$，则 $MV_1$ 可由下式预测： $$ MVP_1 = \\frac{l_1}{l_0} MV_0 $$\n$$ MVD_1 = MV_1 - MVP_1 $$\n编码器只需要传输 $MVD_1$，解码器可按相同规则产生 $MV_1$。\n直接模式 MV 预测\nH.264/AVC 为 B Slice 提供一种 Direct Mode。在该模式下，MV 可直接预测的出，无需传送 MV 差值。预测方式有时域空域两种。时域预测介绍如下。\n设两参考图像 $ref_0$ 和 $ref_1$ 分别位于当前图像的前方和后方，与当前图像的距离分别为 $l_0$ 和 $l_1$，且 $ref_1$ 中与当前块对应位置块有一个指向 $ref_0$ 的 MV，则当前图像的两个 MV 可计算如下： $$ MV_0 = \\frac{l_0}{l_0 + l_1}MV $$ $$ MV_1 = MV_0 - MV $$\nMV 时域预测主要运用了自然界物体匀速运动的思想。\n与 H.264 标准相比，H.265 剔除里 Merge 和 AMVP 两种先进的 MV 预测技术。\n多参考图像及加权预测\n帧内预测 帧内预测模式 亮度帧内预测模式 H.265/HEVC 亮度分量帧内预测支持 5 种大小的 PU，每一种大小的 PU 都对应 35 种预测模式，包括 Planar 模式、DC 模式以及 33 种角度模式。所有预测模式都使用相同的模板。\nPlanar 模式\n由 H.264/AVC 中的 Plane 模式发展而来，适用于像素值缓慢变化的区域。使用水平和垂直方向两个线性滤波器，并将二者的平均值作为当前块像素的预测值。这一做法能使预测像素平缓变化，与其他模式相比能提升视频的主观质量。\nDC 模式\n适用于大面积平坦区域。当前块预测值可由其左侧和上方（不包含左上角、左下方和右上方）参考像素的平均值得到。\n角度模式\n亮度模式的编码 H.265/HEVC 标准建立了一个帧内预测模式候选列表 candModeList，表中有 3 个候选预测模式，用于存储相邻 PU 的预测模式。\n色度模式的编码 共有 5 种模式：Planar 模式、垂直模式、水平模式、DC 模式以及对应亮度分量的预测模式。若对应亮度预测模式为前四种之一，则替换为角度预测中的模式 34。\n帧内预测过程 在 H.265/HEVC 中，35 种预测模式是在 PU 的基础上定义的，而具体帧内预测过程的实现则是以 TU 为单位的。标准规定 PU 可以以四叉树的形式划分 TU，且一个 PU 内的所有 TU 共享一种预测模式。\n帧内预测可分为以下 3 个步骤：\n判断当前 TU 相邻参考像素是否可用（边界或未编码的就不可用）并作相应处理 对参考像素进行滤波 根据滤波后的参考像素计算当前 TU 的预测像素值 帧间预测 运动估计 搜索算法 在基于块运动补偿的视频编码框架中，运动搜索是最为重要的环节之一，也是编码器最耗时的模块。H.265/HEVC 官方测试编码器 HM10.0 给出了两种搜索算法：全搜索算法和 TZSearch 算法。\n亚像素精度运动估计 MV 预测技术 H.265/HEVC 在 MV 预测方面提出了两种新技术，Merge 技术和 AMVP 技术。二者区别主要体现于：\nMerge 可以看成一种编码模式，在该模式下，当前 PU 的 MV 直接由空域或时域上邻近的 PU 预测得到，不存在 MVD (MV Difference)；而 AMVP 可以看成一种 MV 预测技术，编码器只需要对实际 MV 与预测 MV的差值进行编码，因此存在 MVD。 二者 MV 候选列表长度不同，构建候选 MV 列表的方式也有所区别 Merge 模式 为当前 PU 建立一个 MV 候选列表，列表中存在 5 个候选 MV（及其对应的参考图像），通过遍历这 5 个候选 MV，并进行率失真代价的计算，选取率失真代价最小的一个作为该 Merge 模式的最优 MV。若编/解码端按相同的方式键立该候选列表，则编码器只需要传输最优 MV 在候选列表中的索引即可。\nMerge 模式建立的 MV 候选列表包含时域和空域两种情形，对于 B Slice，还包含组合列表的方式。\n空域候选列表的建立 ![]\n时域候选列表的建立 组合列表的建立 对于 B Slice 中的 PU 而言，由于存在两个 MV，因此其 MV 候选列表也需要提供两个预测 MV。H.265/HEVC 将 MV 候选列表中的前 4 个 MV 进行两两组合，产生了用于 B Slice 的组合列表。\nAMVP 技术 高级运动向量预测 (Advanced Motion Vector Prediction, AMVP) 为当前 PU 建立候选 MV 列表，编码器从中最优的预测 MV，并对 MV 进行差分编码；解码端通过建立相同的列表，仅需要将 MVD 与预测 MV 在该列表中的序号即可计算出当前 PU 的 MV。\n类似于 Merge 模式，AMVP 候选 MV 列表也包含空域和时域两种情形，不同的是 AMVP 列表长度仅为 2。\n加权预测 加权预测可用于修正 P Slice 或 B Slice 中的运动补偿预测像素。H.265/HEVC 中介绍了两种加权预测方法：\n默认加权预测\n未使用权值 $\\omega$，根据参考图像队列的不同分 3 种情况计算。\nExplicit 加权预测\n其权值 $\\omega$ 由编码器决定，并需要传送至解码端。也分 3 种情况。\nPCM 模式 在 PCM 模式下，编码器直接传输一个 CU 的像素值，而不经过预测、变换等其他操作。\n对于一些特殊情况，例如当图像的内容极不规则或量化参数非常小时，该模式与传统的“帧内 - 变换 - 量化 - 熵编码”相比，效率会更高。此外，PCM 模式还适用于无损编码情形。\n","date":"2021-03-31T17:04:49Z","permalink":"https://imfaye.me/post/prediction-coding/","section":"post","tags":["HEVC","视频编码"],"title":"H.265/HEVC 预测编码 笔记"},{"categories":["无情笔记"],"contents":"名词一览 GOP (Group of Pictures) - 图像组 IDR (Instantaneous Decoding Refresh) - 即时解码刷新 Slice - 片 SS (Slice Segment) - 片段 CTU (Coding Tree Unit) - 树形结构单元 CTB (Coding Tree Block) - 树形编码块 CU (Coding Unit) - 编码单元 SPS (Sequence Parameter Set) - 序列参数集 PPS (Picture Parameter Set) - 图像参数集 CVS (Coded Video Sequence) - 一个 GOP 编码后生成的压缩数据 VPS (Video Parameter Set) - 视频参数集 编码结构概述 编码结构 视频序列分隔为若干个图像组 (GOP)。\n存在两种 GOP 类型：\n封闭式 GOP\n每一个 GOP 以 IDR 图像开始，各个 GOP 之间独立编解码。\n开放式 GOP\n第一个 GOP 中的第一个帧内编码图像为 IDR 图像，后续 GOP 中的第一个帧内编码图像为 non-IDR 图像。后面 GOP 中的帧间编码图像可以使用前一个 GOP 的已编码图像作为参考图像。\n每个 GOP 又被分为多个片 (Slice)，片与片之间独立编解码。主要目的之一是在数据丢失的情况下进行重新同步。\n每个片由一个或多个片段 (SS, Slice Segment) 组成。\n树形结构单元 (CTU) 类似传统的宏块。每个 CTU 包括一个亮度 CTB 和两个色差 CTB。\n一个 SS 在编码时，先被分割为相同大小的 CTU，每一个 CTU 按照四叉树分割方式被划分为不同类型的 CU。\n以上即为编码时的分层处理架构。\n码流结构 码流结构上，H.265/HEVC 压缩数据采用了类似于 H.264/AVC 的分层结构。\n将属于 GOP 层、Slice 层中共用的大部分语法元素游离出来，组成 SPS 和 PPS。\nSPS 中包含了一个 CVS 中所有图像共用的信息。SPS 中大致包括解码相关信息，如档次级别、分辨率、某档次中编码工具开关标识和涉及的参数、时域可分级信息等。\nPPS 中包含一副图像所用的公共参数，大致包括初始图像控制信息，如初始量化参数、分块信息等。一副图像中所有 SS 引用同一个 PPS。\n此外，为了兼容在其他应用上的扩展，H.265/HEVC 的语法架构中增加了 VPS，其内容大致包括多个子层共享的语法元素，其他不属于 SPS 的特定信息等。\n对于一个 SS，通过引用它所使用的 PPS，该 PPS 又引用对应的 SPS，该 SPS 又引用对应的 VPS，最终得到 SS 的公用信息。\n片段层 一副图像可以被分割为一个或多个 Slice，每个 Slice 的压缩数据都是独立的，Slice 头信息无法通过前一个 Slice 的头信息推断得到。这就要求 Slice 不能跨过它的边界来进行帧内或帧间预测。\n根据编码类型不同，Slice 可分为以下几部分：\nI Slice\n该 Slice 中所有 CU 的编码过程都使用帧内预测\nP Slice\n在 I Slice 的基础上，该 Slice 中的 CU 还可以使用帧间预测，每个 PB（预测块）使用至多一个运动补偿预测信息。P Slice 只使用图像参考列表 list 0。\nB Slice\n在 P Slice 的基础上，该 Slice 中的 CU也可以使用帧间预测，每个 PB（预测块）可以使用至多两个运动补偿预测信息。B Slice 可以使用图像参考列表 list 0 和 list 1。\n一个独立的 Slice 可以被进一步划分为若干个 SS，包括一个独立 SS 和若干个依赖 SS，并且以独立 SS 作为该 Slice 的开始。\n一个 SS 包含整数个 CTU（至少一个），并且这些 CTU 分布在同一个 NAL 单元中。SS 可以作为一个分组来传送视频编码数据。\nTile 单元 Tile 单元描述 一副图像不仅可以划分为若干个 Slice，也可以划分为若干个 Tile。即从水平和垂直方向将一个图像分割为若干个矩形区域，一个矩形区域就是一个 Tile。每个 Tile 包含整数个 CTU。\nTile 提供比 CTB 更大程度的并行，在使用时无须进行复杂的线程同步。\n在同一幅图像中，可以存在某些 Slice 中包含多个 Tile 和某些 Tile 包含多个 Slice 的情况。\nSlice 和 Tile Tile 形装基本上为矩形，Slice 为条带状。\nSlice 由一系列 SS 组成，一个 SS 由一系列 CTU 组成。Tile 则直接由一系列 CTU 组成。\n每个 Slice/SS 和 Tile 至少要满足以下两个条件之一：\n一个 Slice/SS 中的所有 CTU 属于同一个 Tile 一个 Tile 中的所有 CTU 属于同一个 Slice/SS 树形编码块 传统的视频编码基于宏块实现。考虑到高清视频 / 超高清视频的自身特性，H.265/HEVC 标准中引入了树形编码单元 CTU，其尺寸由编码器指定，且可大于宏块尺寸。\n同一位置处的一个亮度 CTB 和两个色度 CTB，再加上相应的语法元素形成一个 CTU。在高分辨率视频的编码中，使用较大的 CTB 可以获得更好的压缩性能。\nH.265/HEVC 为图像划分定义了一套全新的语法单元，包括编码单元 (CU)、预测单元 (PU)、变换单元 (TU)。\nCU 是进行预测、变换、量化和熵处理等处理的基本单元 PU 是进行帧内/帧间预测的基本单元 TU 是进行变换和量化的基本单元 编码单元 大尺寸图像的一个特点是平缓区域的面积更大，用较大的块编码能极大提升编码效率。在 H.264/AVC 中，编码块的大小是固定的。而在 H.265/HEVC 中，一个 CTB 可以直接作为一个 CB，也可以进一步以四叉树的形式划分为多个小的 CB。大的 CB 可以使得平缓区域的编码效率提高，小 CB 能很好地处理图像局部的细节。\n编码单元是否继续划分取决于分割标志位 Split Flag。\n预测单元 预测单元规定了编码单元的所有预测模式。帧内预测的方向、帧间预测的分割方式、运动矢量预测、帧间预测参考图像索引号都属于预测单元的范畴。\n变换单元 TU 的大小依赖于 CU 模式，在一个 CU 内，允许 TU 跨越多个 PU，以四叉树的形式递归划分。对于一个 2N × 2N 的 CU，有一个标志位决定其是否划分为 4 个 N × N 的 TU，是否可以进一步划分由 SPS 中的 TU 最大划分深度决定。\n档次、层和级别 在 H.264 中就有对档次 (Profile) 和级别 (Level) 的划分，它们规定了比特流必须遵守的一些限制要求。而 H.265/HEVC 中在此基础上又新定义了一个概念：层 (Tile)。\nProfile 主要规定编码器可采用哪些编码工具或算法 Level 是指根据解码端的负载和存储空间情况对关键参数加以限制 有些 Level 定义了两个 Tile: 主层 (Main Tile) 和高层 (High Tile)，主层用于大多数应用，高层用于那些最苛刻的应用 满足某一 Level 和 Tile 的解码器应当可以解码当前以及比当前更低的 Level 和 Tile 的所有码流。\n满足某一 Profile 的解码器必须支持该 Profile 中的所有特性。编码器不必实现 Profile 中的所有特性，但生成的码流必须遵守标准规定。\n","date":"2021-03-31T11:34:13Z","permalink":"https://imfaye.me/post/video-coding-structure/","section":"post","tags":["HEVC","视频编码"],"title":"H.265/HEVC 编码结构 笔记"},{"categories":["无情笔记"],"contents":"图像数值表示 分辨率 分辨率的基础单位是像素。1280 * 720 P 的分辨率代表共有 1280 * 720 个像素点。\n一台物理设备出厂时就已经定下了它所能拥有的最大像素点是多少。电脑显示屏调整分辨率是系统通过运算来给出模拟色彩块填充适配的。\n下述像素排列方式内容为 expansion pack，可略过。\n像素排列方式 标准 RGB 排列 LCD 屏幕上常采用标准 RGB 排列，会将一个像素分为 3 个子像素并排排列，通过红、绿、蓝滤色片将 LCD 背光模组的白光过滤后形成相应的 RGB 子像素排列。当需要显示不同颜色的时候，3 个子像素以不同的亮度发光，在视觉上会混合成所需要的颜色。\nPenTile 排列 PenTile 排列多见于 OLED 屏幕上，因子像素呈现钻石排列而得名。PenTile 排列的每个像素由红、绿和蓝、绿子像素组合而成，绿色像素是完整的，而红蓝像素相比传统 RGB 排列各减少二分之一，子像素总数减少了约三分之一。\n不像标准 RGB 排列每个像素更加独立，PenTile 排列在显示许多内容时需要借用相邻像素，显示精细内容时同分辨率下相较标准 RGB 排列的屏幕细腻度不足。\n蓝色 OLED 的发光效率要比红色和绿色低，达到相同的发光强度必须使用更高的通过电流，因而蓝色像素衰减速度更快，也就会加速“烧屏”现象的产生。\nYUV 表示方式 对于视频裸数据而言，更多使用 YUV 数据格式显示。\nY 表示明亮度 (Luminance / Luma)，即灰阶值 U、V 表示色度 (Chrominance / Chroma)，描述色调饱和度 亮度通过 RGB 输入信号来建立，方法是将 RGB 信号的特定部分叠加到一起。色度定义了颜色的色彩和饱和度，分别用 Cr 和 Cb 表示。Cr 表示 RGB 输入信号红色部分与 RGB 亮度值之间的差异，Cb 表示 RGB 输入信号蓝色部分与 RGB 信号亮度值之间的差异。\nYUV 优点 与黑白电视机也能兼容\nY 和 UV 分量分离，只有 Y 分量就是黑白图像。\n相较于 RGB，YUV 数据格式占用空间小\n人眼对色度的敏感程度低于对亮度的敏感程度（因为识别亮度的视网膜杆细胞比识别色度的视网膜锥细胞多）。将色的信息减少，人眼也无法察觉。且并不是每个像素点都需要包含 YUV 三个分量，根据不同的采用格式，每个 Y 分量可以对应自己的 UV 分量。\nYUV 采样格式 YUV 4:4:4 采样 每个像素三个分量信息完整。\n举个例子，一张 1 * 4 的图片：\n图像像素为：[Y0 U0 V0]、[Y1 U1 V1]、[Y2 U2 V2]、[Y3 U3 V3]\n采样码流为：Y0 U0 V0 Y1 U1 V1 Y2 U2 V2 Y3 U3 V3\n最后映射出的像素点依旧为 [Y0 U0 V0]、[Y1 U1 V1]、[Y2 U2 V2]、[Y3 U3 V3]\n一张 1280 * 720P 的图片使用 YUV 4:4:4 采样，大小为：\n1280 * 720 * 3 / 1024 / 1024 = 2.636 MB YUV 4:2:2 采样 Y 分量和 UV 分量按 2:1 的比例采样。\n举个例子，一张 1 * 4 的图片：\n图像像素为：[Y0 U0 V0]、[Y1 U1 V1]、[Y2 U2 V2]、[Y3 U3 V3]\n采样码流为：Y0 U0 Y1 V1 Y2 U2 Y3 V3\n最后映射出的像素点依旧为 [Y0 U0 V1]、[Y1 U0 V1]、[Y2 U2 V3]、[Y3 U2 V3]\n一张 1280 * 720 P 的图片使用 YUV 4:2:2 采样，大小为：\n(1280 * 720 + 1280 * 720 * 0.5 * 2) / 1024 / 1024 = 1.759 MB YUV 4:2:0 采样 不是指没有 Cb，而是意味着第一行 Y 分量和 U 分量按 2:1 的比例采样，第二行 Y 分量和 V 分量按 2:1 的比例采样。Y 分量和 UV 分量按 4:1 的比例采样。\n举个例子，一张 2* 4 的图片：\n图像像素为：[Y0 U0 V0]、[Y1 U1 V1]、[Y2 U2 V2]、[Y3 U3 V3]、[Y4 U4 V4]、[Y5 U5 V5]、[Y6 U6 V6]、[Y7 U7 V7]\n采样码流为：Y0 U0 Y1 Y2 U2 Y3 Y4 V4 Y5 Y6 V6 Y7\n最后映射出的像素点依旧为 [Y0 U0 V4]、[Y1 U0 V4]、[Y2 U2 V6]、[Y3 U2 V6]、[Y4 U0 V4]、[Y5 U0 V4]、[Y6 U2 V6]、[Y7 U2 V6]\n一张 1280 * 720 P 的图片使用 YUV 4:2:0 采样，大小为：\n(1280 * 720 + 1280 * 720 * 0.25 * 2) / 1024 / 1024 = 1.318 MB YUV 存储格式 planar 平面格式\n先连续存储所有像素点的 Y 分量，然后存储 UV 分量。\npacked 打包模式\n每个像素点的 YUV 分量连续交替存储。\nRGB 和 YUV 转化 对于图像显示器来说，它是通过 RGB 模型显示图像的，而在传输图像数据时又是使用 YUV 模型的。因此两种模型需要互相转化。\n有如下公式：\nY = 0.299 * R + 0.587 * G + 0.114 * B U = - 0.147 * R - 0.289 * G + 0.436 * B V = 0.615 * R - 0.515 * G - 0.100 * B R = Y + 1.14 * V G = Y - 0.39 * U - 0.58 * V B = Y + 2.03 * U IBP 帧 I 帧 (intra picture)\n内部编码帧（也称为关键帧），通常是每个 GOP 片段的第一帧，经过适度压缩，作为随机访问的参考点，可以当作静态图像。I 帧压缩可去掉视频的空间冗余信息。\nP 帧 (predictive-frame)\n前向预测编码帧（也称为预测帧），通过将图像序列中前面已编码帧的时间冗余信息去充分去除压缩传输数据量的编码图像，需要参考前面的一个 I 帧或者 P 帧才能解码成一张完整的图像。P 帧可以简单理解为当前帧画面与前一帧的差别。\nB 帧 (bi-directional interpolated prediction frame)\n双向预测内插编码帧（也称双向预测帧），需要参考前面的一个 I 帧或者 P 帧以及后面的一个 P 帧才能编码成一张完整的图像。\n简单来说，I 帧是一个完整的画面，而 P 帧和 B 帧记录的是相对于 I 帧的变化。如果没有 I 帧，P 帧和 B 帧就无法解码。压缩比 I 帧 \u0026lt; P 帧 \u0026lt; B 帧。\nGOP 编码器将多张图像进行编码后生产成一段一段的 GOP (Group of Pictures)，解码器在播放时则是读取一段一段的 GOP 进行编码后读取画面再渲染显示。GOP 是一组连续的画面，由一张 I 帧和数张 B / P 帧组成，是视频图像编码器和解码器存取的基本单位。gop_size 描述的是两个 I 帧之间的帧数目。\n码率和帧率 帧率 (Frame Rate) 表示每秒实践显示的帧数（Frames per Second，简称 FPS）。\n对于人眼来说，如果所看画面的帧率高于 24，就会认为是连贯的，此现象称为视觉暂留。\n码率（比特率） 码率指每秒传输的比特数，单位为 bps (Bits Per Second)，通俗一点讲就是取样率，单位时间内取样率越大，精度就越高，处理出的文件就越接近原始文件。\n文件体积与取样率成正比，所有的编码格式都很重视如何用最低的码率达到最少的失真。\n码率简单来说是指再压缩视频时给这个视频指定一个参数，用以告诉压缩软件期望的压缩后视频的大小。\n参考 视频基础知识扫盲\n一文读懂 YUV 的采样与格式\nIBP帧\n","date":"2021-03-29T15:10:25Z","permalink":"https://imfaye.me/post/multimedia-basics/","section":"post","tags":["多媒体","视频编码"],"title":"多媒体基础知识"},{"categories":["折腾"],"contents":"网络代理配置 刚开始用 apt-get 就被卡到。\nWSL1 的时候，Linux 子系统和 Windows 主机是共享一个 localhost 的。WSL2 由于通过虚拟机实现，若要访问 Windows 主机的网络，需要使用主机的 IP 地址（IP 地址可以用 ipconfig 命令查看）。\nWSL2 环境变量配置 如果是 V2rayX 的话，默认 socks5 端口是 10808，默认 http 端口是 10809。\n如果是 Clash for Windows 的话，默认 socks5 端口是 7891，默认 http 端口是 7890。\n以个人经验教训来说，http 和 socks5 两种代理方式可以都尝试一下。\nexport http_proxy = \u0026#34;socks5://\u0026lt;windows_ip\u0026gt;:\u0026lt;socks5_port\u0026gt;\u0026#34; export https_proxy = \u0026#34;socks5://\u0026lt;windows_ip\u0026gt;:\u0026lt;socks5_port\u0026gt;\u0026#34; git 也可以设置使用代理。\ngit config --global http.proxy \u0026#34;socks5://\u0026lt;windows_ip\u0026gt;:\u0026lt;socks5_port\u0026gt;\u0026#34; git config --global https.proxy \u0026#34;socks5://\u0026lt;windows_ip\u0026gt;:\u0026lt;socks5_port\u0026gt;\u0026#34; 当然，如果希望每次启动的时候代理配置都生效，可以写入 ~/.bashrc 文件中。\n顺便一提查看 git 全局配置的命令是：\ngit config --global --list V2ray 配置 在设置中要勾选上「允许来自局域网的连接」。\n默认 shell 设置 执行 chsh 命令打开新的 WSL 窗口的时候，默认 shell 仍然没有变化。\n还是需要在 ~/.bashrc 中加上一行：\nbash -c fish 当然如果是 zsh 还是 fish 就随意啦。\n","date":"2021-03-21T20:29:24Z","permalink":"https://imfaye.me/post/wsl/","section":"post","tags":["WSL"],"title":"Win10 下 Linux 子系统 (WSL) 配置小记"},{"categories":["正是在下"],"contents":"果然，日记吧\u0026hellip;不是能全部坦诚相待的东西。这里只是一部分的真实的我。\n2020 2020/4 4/18 晚上和爸爸妈妈一起去走南山绿道。刚下完雨，空气里完全是水汽。能闻到那种水汽的味道。天空暗下来，旁边是茂密的树林或竹林，有绿色的灯照出雾气，路上谁都没有。聊起了以前出去旅游的事情。去木桥那打手机的手电筒看一大片山谷里的杜鹃花。路上有小学经常闻的那种野花的幽香。后来回来半路又下雨了。淋了一场雨一起回家。爸爸说淋一场春雨不是很好吗。\n回来之后，洗完澡一边喝牛奶一边和妈妈看快乐大本营。\n我真的只想有一些这样的温馨和细小的满足就行了。像小时候一样。\n4/17 想起了之前听随机波动。新闻的关注全都给了可以被数据可视化的内容。没有办法呈现出一个一目了然又蕴含爆炸性信息的东西，可能完全不会被分到注意力，也完全不会被新闻从事者所费力去挖掘。那么长的叙事，平淡的，无法给你颠覆性的视觉冲击的东西，就注定要被人忽略吗。\n靥足。\n4/14 上午把钢炼看完了。哭了。\n后来心情还是不好。一直在看月曜。\n4/13 感觉好久没上课了一样。\n妈妈买了很多吃的回来，还买了香水百合放在餐厅。外面阳光超好。我都有点想哭。\n晚上一直在看钢炼。\n4/11 晚上菊梅姐姐他们来我们家，和妮妮聊了很久，妮妮真的成熟了好多。一起看电视，名侦，柯南什么的。晚饭的时候，我还炒了刀豆丝。\n说一下最近查资料有意思的事情。\n总是想起那个教授说的，我们检索记忆的方式，不是倒放，而是直接抽取过去某个点。\n人脑存储记忆的方式。回想是一个重构的过程。随着每次检索，都会改变。大脑对概念的优先级高于细节。\n4/3 早上竟然就在床上听完了机器学习。这个老师好憨。\n中午一直在看些经验视频。别的小姐姐好温柔。诚实一点。这就是你，这就是你的大学四年，你花在其他地方的时间一定也是有意义的。鸡汤如果可以拯救我一小下，我烂俗一点也无妨。\n看了一些语言学的视频。\n下午看了看瑞幸那事。想起之前听的剩余价值了。资本真的在侵压我们所有的生活空间的小角落，从公到私。压榨剩余价值，侵入，一切追求效率利润最大化。我还是觉得，它应当只作为被提供的选择出现，而不是强制性地挤压所有弹性空间。小商小贩，我们的个性化的充满生活气息的小角落，不得不和巨型资本融合。我们真的需要那么强的便利性吗，我们只是一味地被市场投喂，靥足之后进化出妖怪一样的欲望。\n听剩余价值，这期聊足球。\n英国两大工业城市，曼彻斯特，利物浦。所以曼联和利物浦一直是宿敌。\n有球能力和无球能力。梅西有球能力强，C罗无球能力强。而电视转播通常视线是围绕着球的，难看见无球能力。\n4/2 N号房 色情 和纸片人 和真人(可是随着以后技术的发展，纸片人的同意与否是否需要被考虑) 限制级，因为小孩子分不清虚拟和现实 想象力不能被取缔\n并不是主体与主体之间的关系，对女性开的色情玩笑，本质上更期望获得同性的认同，女性只是工具，男性共同体的认同感，排除自己同性恋倾向的嫌疑，因为被男性共同体所鄙视\n对了，无线键盘到了。\n每天应该更有干劲一些。\n4/1 今天回了江心。好久没回去过了。汽渡，过江。\n烧纸，然后去姨娘家吃饭，还看了小舅还在起的新房子。\n到的快递竟然有一个是之前的托福成绩单。\n2020/3 3/29 不记得了。\n最近一直在听indigo la end的tulip，川谷果然很厉害，那种又温暖又无法挽回的失落感。\n可能在写樱花诗赛的诗。\n3/28 看钢炼。\n晚上妈妈带了牛肉汤和葱油饼。吃完之后一起去走南山绿道。\n看远处的字。走亭廊。竞走。\n3/26 昨天夜里好大的雨，好大的雷。\n今天终于装修的安静了一天。\n看魔兽战线。人与神共存。无理的，残酷的，可以怪罪到神和未知的事情上，不必那么痛苦。神所理解的善。还有后面提亚马特，被人类史所不需要的神。\n大概可以理解一些迷惑的展开。不过画面没得说啊，我果然是氛围感控。今天本来也下着雨，有点找到那种清冷的感觉。\n看见别人发了朋友圈回忆附中。啊，怎么说，当时那么有反叛精神的人也有如此传统的温情时刻吗，少年时代真的是一去不复返吗，它是作为我们的一部分隐匿在记忆里与我们共存，还是被以后的展开取代只是能找到合理的解释与去往根源的通路呢。变得正确，就变得无聊了，但也是变得靠谱成熟了。是我自己在拒绝成为独挡一面的大人吗。\n晚上看完了魔兽战线，梅林的花瓣，西杜丽，安娜，小恩的天之锁。喜欢闪闪，更理解三王会谈里闪闪说的孤高了，后悔，想去拯救，对宿命的否认，对人民挣扎姿态的怜悯也就是对自己的领导和对他们的侮辱。你的善良是一种割裂，是一种软弱和逃避，也因为他始终能看见未来吧，始终把现在和未来看成一个连续的整体，肯定现在就是在肯定未来，所以无需去后悔。不过对于亚瑟来说，她的确不是自己选择去成为王的，她对每一个个体都怀抱着同情吧。\n3/25 晚上妈妈回来带了淮南牛肉汤，还吃了蛋挞。满足~\n最近觉得自己有进步的地方是，终于没有那么容易羡慕别人了。本来，自己不塑造自己，靠这种与外界的牵连也很脆弱吧。\n3/24 依旧，装修的声音让人简直神经衰弱。有在看魔兽战线。喜欢闪闪。\n上午和红叶打电话，聊天。嗯，跳出那个框子，稳固一点弥补自己觉得应该弥补的，不用太担心会和高中一样，也不用太高地期望什么。\n老婆饼，榴莲酥，青团，酸奶拌香蕉。\n下午后来在研究吉尔伽美什和恩齐都。后来和污妖王聊了会儿天，我完全都不知道原来新加坡现在疫情愈发严重了。有点可怕。\n后来还和春花聊天。后来看特朗普的视频太好笑了。\n3/23 听课。装修的声音也太吵了。\n昨天晚上看完了异度侵入的结局，有点失望。一切停在第10集就好了。\n中午吃了粥和汤圆。然后和妈妈出去散步。春光明媚。御龙湖那简直像是桃花岛。\n杨柳，樱花，草地，好多好多的海棠。完全烂漫。湖水真的像纱。縠纹一词很准确。苏轼的\u0026quot;夜阑风静縠纹平\u0026quot;。还有旁边的别墅。像童话。\n然后也去了南山。又看了樱花。\n3/22 说起来这两天在玩FGO。贞德，玛丽女王，莫扎特。\n可是玩游戏真的太让人焦躁了。\n听了切嗣和太太的广播剧。觉得切嗣其实是比士郎温柔的。现在会觉得，过于明朗脆弱积极正确反而是一种迟钝的神经大条。敏感的温柔的，是不是最后都会像那样伤害自己。\n不能停下，也不是为了不破坏自己信仰的正确，而是一旦停下，被自己牺牲的人就太无辜了。而自己也知道自己以这样审判者的角度帮别人或世界裁定正义是一种不自量力的傲慢。\n切嗣让爱丽选择，爱丽说，若你确信自己的选择是一定正确的，就不会让我去选择了吧。你教会我的东西，你让我看到的世界，都是你转身拒绝的东西吧。爱丽并不完全知道切嗣的理想，但她几乎完全理解切嗣这个人。\n相信一个人。我也想啊，我会相信你，你的安利就算当下的我并不get，但存下来也许以后的日子里我们的时间线会交汇收束，知道，啊，原来那时候的你是这样想的啊。\n为什么可以相信一个人呢。大家都会变的，我自己都讨厌比从前更差的自己。所谓信任，还是和共同度过的时间消耗有关吧。就好像中学同学，我们之间的联结也就是那段一起度过的时光而已，之后的你的变化总也从某个时间点开始的，而我可以回溯到一个确切的源点时间段，因为不是无头无尾我完全无法触及的轨迹，所以我不会那么恐惧，所以我会莫名产生信任吗。\n3/21 等妈妈下班回来，和爸妈一起去南山看了樱花，走绿道。小亭子。干涸的水库。大片的野花。竟然那儿还有住宅。\ndawn 草坪，那个住宅就像藏在森林和溪水里的小木屋，透出暖黄的光，像萤火，黄昏是逢魔之时么，让我觉得周围散布着绽放的蓝紫色的花。\n3/20 早上难得早起。\n突然想到，稍微有点难过。一直以来，其实自己都很固步自封。以前也有说过吧，其实大学以来每学期的期末周反而是我最快乐的时候。可以说我无聊吧，其实我还挺喜欢看教材，复习，考试，和同学讨论，还有比成绩的孩子气。高中开始就是这样，所有人忙着竞赛忙着自招，就算是高考前一个月的晚自习里，班上的氛围都让我觉得自己在那做模拟卷复习高考是一种羞耻的行为。我喜欢英语，喜欢作文，喜欢戴着镣铐跳舞还能保留一点自己的意气，但别人从根源上脱离了镣铐，不需要小聪明，你们完全不在一条道路上竞争。大学虽然原因不一样，但大家确实也不在一条道路上，零零散散的。所以期末考试了，所有人看同样的教材，想着同样的问题，为一样的考试在努力，存在某种联结，我并不讨厌。\n看完了FZ。还是很心疼切嗣。\n3/19 好像一直在看交换原理。晚上写作业画图画benes什么的要吐。\n看FZ，其实还是挺喜欢切嗣的。成王败寇而已，英雄传说又何尝不是胜者编造的华丽的假象。沉湎于骑士道，沉湎于自己的荣光和骄傲，而不去承认战争只要存在就一定是肮脏的。\n可是也有另一种解释我也很受触动，人需要信仰，就算不择手段可以带来结果正义，道德和大义的丧失会让人们缺乏希望，甚至活下来也不能有精神支撑继续活着。(这点上来说pp剧场版里的朱爷似乎做的很好？明明知道让人们选，他们其实不会选择自由。但这个拥有自由的选择的仪式，会让他们活得更好。)说白了，人还不是太脆弱了，我们所言的信仰，只是因为我们需要这种美丽的谎言所以才将一切美好的想象倾注于它而已。所谓大义凛然的信仰，本质上又和我们所唾弃的饭圈追idol有多大区别呢。都是因我们需要而存在的狂热。\n也听了剩余价值。邻近的缺失。我们真的需要便捷的网购资源吗，在全世界范围内生产成本最低的地方进行资源的压榨，破坏平衡。中央厨房追求的是标准化，消费者逐渐丧失选择权。坂本龙一对工业文明的反思，音不准的钢琴，想要脱离塑性去回归自然。\n3/18 看FZ。三王会谈。王应当是孤高的吗。身而为人，却怀着非人的悲愿。王后悔的瞬间，就是对自己的统治，对拥护自己的臣民的背叛，为何不愿意接收自己的统治必然带来的影响和必然走向的宿命呢。不应当成为“正确”的奴隶。永远正确，为他人牺牲自己，是骑士，而不是王。\n晚上吃了很多。菠萝炒饭之后又吃了一碗酸奶拌香蕉还有草莓。\n3/17 结果没做什么。\n3/16 早上起来看了异度侵入12集\u0026hellip;唔，不是我期望的反转\n中午吃了菠萝虾仁炒饭。妈妈边在厨房做饭，我边在旁边聊天。中午，天光很亮堂。很悠闲。\n下午和妈妈出去了一趟。然后在小区转了一圈。啊，真的到春天了呢。上一次出去还是冬天，现在出去已经能感觉热了。\n3/15 一天都在看漫画\u0026hellip;\n晚上听歌唱歌很high\n想起以前看fate那种中二感了\n3/14 春天。每一年的春天在我这带着点这样的色彩。泛暖的空气。\n一定有夕阳的茜色。浅一点的，像淡水彩。粉色的莫扎特。再带一点橘色。\n也一定会想起小学三四点放学急着赶回家看一集犬夜叉的时光。初中骑自行车回家路上已经能看见夕阳拖长的影子了，是橘色的。高中总是晚自习后才回去，有点可怕。只有小学，回家的时候，放学路上可以大步走，天空还是明亮的蓝色，和犬夜叉第一个op开头一样的蓝色。\n竟然卡在巴黎篇没有立马继续看下去。还是因为讨厌自己吧。天赋，努力，自己争取的未来，自己维护的梦想。看着他们，会觉得自己的生活纯度太低了。\n3/13 喜欢千秋第一次指挥成功后，躺在长椅上，野田妹的脸蛋被夕阳映得红红的很可爱。学长假装不知道说那是谢礼。\n晚上把交响情人梦第一季看完了。啊。自己要努力啊。\n3/12 看交响情人梦。想起来那张图，千秋穿着黑礼服，为穿着绿裙子的野田妹打开门。\n所以说啊，为什么呢，现在的番很多会觉得精彩，但不能动情。交响情人梦让我想起小学的时候，也是春天回暖的时候，那种下午有点温暖有点氤氲的气氛。\n下午还看了红辣椒。从表现被压抑的意识的意义上来说，你不觉得网络和梦境很像吗。\n3/11 似乎是这一天吧。开始看交响情人梦。好喜欢。\n3/10 睡到中午。开始看视频。感觉脑袋昏昏沉沉的，都很难集中注意力。\n看了异度侵入11集。时间因为观察者的存在而有意义。\n看了PP的剧场版。\n以前的认知是，累的时候似乎很难做梦，现在觉得，累的时候，似乎是很难记得梦，其实也是做梦的。 是不是当现实忙碌起来的时候，现实和潜意识会分隔得更清楚呢。喜欢ID的地方甚至不在于推理或者时间线，而是潜意识，梦，还有对推理小说本身定义的探索。metadata\n但是，又觉得，现在的番当然也很精彩，但很难把它当成信仰那种感觉了。毕竟为世界观和某个角色买单要比为剧情买单要死心塌地得多。为什么呢，触感？要有深度的同时，还得是积极的？要有我喜欢的感情发展模式，还得很有美感？\n在弹幕里看见有人说春哥很像朱爷。确实，瓢哥也是原刑警。有点像哦。\n真的好喜欢call酱。想被他夸。\n然后就是，自己越来越烂了。也不想也不知道怎么亲切地和朋友保持联系。果然，多于两个人的话，我就倾向于当透明人，只想听着，把自己封闭起来默认所有对话与我无关。觉得，别人很优秀啊很可爱啊人很好啊，所有东西他们都值得，都给他们好了，我没有什么非存在不可的理由。我明明最想要的是和自己类似的同伴，一个人就好，不说话也可以相互理解，长时间不交流依然对亲切感有信心，尽管每个人都在变世界也在变可对羁绊的信念始终有坚实的基础。\n可是纵观我从小到大的好朋友，大部分都是很开朗很能干在世俗上可以很得心应手的人，我被她们照顾，和她们一起出去，我似乎什么也不用主动，也不用去耗费精神力去和不熟的人打交道。\n2020/1 1/26 最近的状态太差了。每天就刷微博。有点难过，气愤，也会无感。\n也不学习。看DRRR。\n不过今天开始变高兴起来。各种苏联笑话还有网友宅家里找乐子的法子。\n1/25 大年初一。反正也没出去。\n1/24 嗯，除夕。\n吃饺子。\n在客厅看春晚。贾玲和开心麻花两个小品其实也挺好笑的。\n1/18 又是头晕的一天。\n看庆余年看到后面不想看了。价值观不合吧。还是爽文。\n你没有办法站在自己完全不平衡的时代背景，教育程度，文化水平去批判那个时代的人们。大多数情况下，你也当不了男主，也没有贵人相助，就这样随心所欲逆天改命去践行自己就算是正确的价值观，也太狂妄了。百姓不知道，你告诉他们他们也怕知道。兴，百姓苦，亡，百姓苦，但水能载舟亦能覆舟，历史里没有他们的名字，但他们确确实实就是历史的主体。\n后来看了无人知晓。\n1/5 复习算法，在二楼小教室。还挺投入的。一直看到两点。去咖喱屋吃牛肉饼咖喱饭。\n回来趴着看了好久MV什么的。\n晚上下雪了。下得可大了。絮絮扬扬的。地上白白的一层，亮晶晶的。\n2019 2019/12 12/30 今天一天在看编译原理。明天要考试了，为什么今天还是觉得这么轻松，心态像是回到了小学初中那会儿。\n吃晚饭回来路上中彩了\u0026hellip;乌鸦叫得好大声，树上，天空里，全是的，有点吓人，今天风很大还很冷。\n我是不是应该稍微紧张一点\u0026hellip;\n为什么，最近尤其容易想乱七八糟的事，想要一个拥抱什么的。昨天晚上听剩余价值要不要同居那一期。总之，感情是会越来越坏的。我感觉自己也是理智上都释然不抱希望了，但作为我这个个体来讲，拥有那种童话一般的纯净的希冀好像是我的一个特性，我没办法变成那样洒脱的开化的人，总有怯懦的纯真的稚气。\n12/28 在二楼大教室看操作系统。\n中午去咖喱屋吃了照烧鸡排饭。坐在玻璃窗旁的位置。外面是冬天的街道。窗台边有花。想起了什么。微微明亮的，冬天干净的，街道市景。像玉响。\n大家为什么总是这样，示弱的同时也暗戳戳保留着秘密在炫耀。总有被避开的无助感。\n又自闭了。\n12/21 在寝室呆了一天。效率略低。\n数学竞赛竟然是一等奖。有点惊讶\u0026hellip;\n晚上吃完饭和逸菲散步，楼里一层一层地转。\n抓紧复习啊你！\n12/19 下午健美操课录视频看了看队形。\n晚上去吃了付小姐在成都。串串。酸辣粉。红糖糍粑。小酥肉。冰粉。\n晚上听了那个日本文化讲座。江户时期的庶民文化。\n歌舞伎 倾斜；城下町；葛饰北斋 神奈川冲 浪里（停顿是这样的,冲是海域的意思）\n《日本人的心理结构》 依赖心理 娇宠 同性恋情感 夏目漱石 心\n后来我还提问了。反正全都不认识，一点不丢人。\n12/17 下午计网去实验室配路由器。juniper\n最后终于通了嘻嘻。一直到八点才走。\n报名托福！别浪费了钱啊！\n12/12 上午在干什么呢。好像在写操作系统的实验报告。\n在听indigo的骤然恋情。有点悲伤。\n下午体育课依旧在练队形。\n晚上和胖胖燕南慧慧一起去悸动，去吃烤冷面，去买小熊饼干。\n希望indigo可以让我感动。我最近有点太脆弱了。\n晚上去疆进酒看演出。找靠边的地方放了包靠着。\n一首一首接着唱。到后面我完全沉醉。陪伴我刷数学的歌，这几天陪我悲伤质疑自己的歌。\n巩哥穿白色卫衣，很有少年感，跟着节奏摇摆，就很帅啊。\n回来的地铁和公交车，人都不多。\n很久没有过的，也和L同学在朋友圈说了一言两语。去年这时候，课巨多的时候，我好像特喜欢在宿舍自习室，当时很期待朋友圈各种互动呢。\n12/9 昨天晚上没睡好。\n中午回来看psycho pass。看完第一季了。哭的我。\n12/5 昨天晚上看了before sunrise\n太浪漫了。火车上窗边聊天，临时起意跟他下车，唱片店偷瞄，在维也纳四处游荡，遇见路人，摩天轮，诗人\n一刻的，一瞬的，那是最接近于完满的。没办法做到不期待理想的永恒的什么。\n早上起得挺晚。\n体育课之后去村上一屋吃寿喜锅，乌冬面，三文鱼寿司，榴莲芝士大卷。之后还去旁边味多美买了老婆饼。\n去旁听英语口译课。李开复的ted演讲。原来labor有分娩的意思，deliver也有。\n晚上在宿舍玩你说我猜。唉，我好没常识的。后来还开始比划。\n12/3 今天天气好好，风也不大，也不冷。\n想出去玩但没契机。\n看了modern love第六集和第七集的一半。\nI\u0026rsquo;m really proud of you. 所谓父爱\n看before sunset\n太好看了！\n\u0026hellip;he\u0026rsquo;s there. He\u0026rsquo;s there, in both moments, simultaneously.\nAnd just for an instant, all his life is just folding in on itself.\nAnd it\u0026rsquo;s obvious to him that time is a lie.\n\u0026hellip;and inside every moment is another moment\u0026hellip;\n\u0026hellip;all happening simultaneously.\n\u0026hellip;you know, to be in the moment. I mean, I feel like I\u0026rsquo;m\u0026hellip;\n\u0026hellip;designed to be slightly dissatisfied with everything, you know?\nIt\u0026rsquo;s like always trying to better my situation.\nI satisfy one desire, and it just agitates another.\nAnd then I think, to hell with it, right? Desire\u0026rsquo;s the fuel of life.\nI don\u0026rsquo;t know. Not wanting anything, isn\u0026rsquo;t that a symptom of depression?\nI like that we have those ever-renewing desires, you know?\nMaybe it\u0026rsquo;s this sense of entitlement.\nYou know, like whenever you feel like you deserve that new pair of shoes?\nIt\u0026rsquo;s okay to want things, as long as you aren\u0026rsquo;t pissed off if you don\u0026rsquo;t get them.\nHe looked like he needed help, but his first reaction was to photograph him.\n\u0026hellip;totally detached from the person.\nPeople just have an affair, or even entire relationships\u0026hellip;\n\u0026hellip;they break up and they forget.\nThey move on like they would have changed brand of cereals.\nI was looking at chestnuts falling from the trees, rolling on the sidewalk\u0026hellip;\n\u0026hellip;or ants crossing the road, the way a leaf casts a shadow on a tree trunk.\nLittle things.\nI think it\u0026rsquo;s the same with people.\nI see in them little details, so specific to each of them\u0026hellip;\n\u0026hellip;that move me and that I miss and will always miss.\nI remember thinking at the time\u0026hellip;\n\u0026hellip;that so many of the men that I admired most\u0026hellip;\n\u0026hellip;that their lives were dedicated to something greater than themselves.\nSo you got married because men you admired were married?\nNo, no. It\u0026rsquo;s more like I had this\u0026hellip; This idea of my best self, you know?\nAnd I wanted to pursue that\u0026hellip;\n\u0026hellip;even if it might have been overriding my honest self.\nIt reminded me how genuinely romantic I was\u0026hellip;\n\u0026hellip;how I had so much hope in things\u0026hellip;\n\u0026hellip;and now it\u0026rsquo;s like I don\u0026rsquo;t believe in anything that relates to love.\nI don\u0026rsquo;t feel things for people anymore.\nIn a way, I put all my romanticism into that one night\u0026hellip;\n\u0026hellip;and I was never able to feel all this again.\nLike, somehow this night took things away from me\u0026hellip;\n\u0026hellip;and I expressed them to you, and you took them with you.\nIt made me feel cold, like love wasn\u0026rsquo;t for me.\n如果可以有那样的人的话，想一起去巴黎，在塞纳河边聊天。\n心情很好。去南门的路上给妈妈打电话。很美好很平静。I regain my peace.\n去悸动吃了一碗双皮奶芋圆一号。\n晚上也去吃了饭，回来还吃了思如的炸鸡。\n晚上一直在搞百度云的限速\u0026hellip;aria2, proxyee down, 直链插件+idm, 直链+vlc网络串流\n2019/11 11/29 上午把操作系统的生产者消费者实验报告写了。\n下午第一节课去和胖胖一起听了他们的数学课。人很少，很舒坦，我在补编译原理作业。\n后来编译原理一节课之后就溜了。去自习室看modern love（大概是因为前一天四点醒来，听了一个小时剩余价值）\ndoorman的故事最后还挺感人的。\n晚上下雪了。初雪。还挺大的。\n我走到外面给秋阳打电话。不想看书了，于是早早回宿舍，路上给妈妈打电话，下雪了，前几天都没睡好。\n晚上继续看modern love. 安妮海瑟薇演的那一集，bipolar girl\n初雪，你有想一起看初雪的人吗。你有想陪伴在冬天的温暖灯光下，温热白汽旁，看雪的人吗。\n11/21 开始写了点算法。其实我也不讨厌写代码吧，更擅长一点就好了\u0026hellip;我很害怕。\n中午写给胖胖生日的信和贺卡。习惯照顾别人的人自己也要被照顾好呀。\n晚上喝了芋泥珍奶。一起去吃赤焰。吃得好饱。炒乌冬，猪五花，牛嫩肩，和风麻薯（炸的，蘸草莓冰淇淋），菌菇拼盘。\n11/17 写形式与政策。人类命运共同体。扯到了赵汀阳的天下体系。\n风也太大了，打篮球的和看篮球的都还好吗\u0026hellip;\n11/9 在教室看OS，做笔记。莫名觉得很悠闲。\n中午回宿舍和逸菲一起出去吃了牛肉汤和饼，回来思如还分了鸡米花和蛋挞\u0026gt;\u0026lt;\n小重山。笛子好欢快。突然觉得我爱的江南小调，就是笛子那个音色。填了北师一个问卷。觉得自己意外是一个正派的人哈哈哈。\n听剩余价值。莎翁的创作欲来源于overplus will 不似骄阳 生死爱欲\n晚上和逸菲一起回宿舍，逛旁边小超市还逛了好久，买了辣条回来吃。\n11/5 一个语言没有很强的冒犯性，也就没有很强的幽默感。听剩余价值。汉德克 戏剧 骂观众\n11/2 早上很早就起来了，去做北马志愿。京东仓库。\n和经管院的那个女生一起在后面拆袋子。还挺开心。\n后来一起装袋子。再后来吃盒饭，有去和之前军训那个小姐姐说话。\n下午回来之后复习编译原理。好累好困。\n晚上胖胖和菁璇都来我们宿舍侃，很热闹，她们都是明天早上的志愿，一起三四点起来一起出发。\n晚上本应该早睡的，还是在听广播，意料之外发现很多不错的播客。\n2019/10 10/31 上午有去听胖胖他们的编译原理。像pringle小胡子的老师，很有激情。\n下午体育课很热。上完课去买了悸动的芋泥珍奶然后上形势与政策，老师特有意思。想去俄罗斯！想看梵蒂冈的教堂！\n晚上又去听了英语口译课。写算法的实验报告。\n晚上回来和逸菲周瑜开心地泡泡面吃。\n10/28 中午和慧慧去吃分米鸡。白吃真划算。\n买奶茶。逛了会儿街。人很少嘻嘻。\n去教学楼写数据库实验。\n晚上乱入了电影赏析课（大概412），放了《大河恋》，好治愈的风光。像诗一样美。想起高中放学看教父。\n最亲近的人也许反而是我们最不了解的人，而我们完全可以完整地爱我们并不完整了解的人。\nI\u0026rsquo;m haunted by the waters.\n10/27 和燕南去看少年的你。喜欢秋天的北京。金黄的。凉爽的。还有湛蓝的。\n买了元气水。看完去牡丹园吃姥姥家春饼。之前还买了烧饼。香辣肉丝，炒合菜，酥炸里脊。好撑，吃不完还打包了。\n10/23 今日，宜洒脱\n洒脱不起来呢\n好害怕好害怕，我真的好害怕\n夜里无星 你是银河的雏形 我是黑矮星 哈我在看傅里叶级数\n10/22 上午吃多了。终于尝到了烧卖，但没那么好吃。\n我好差劲。\n又听剩余价值 阿迪契 女性 人类 主义是好的，但主义会伤害主体性 其实是想争取更多的中间派 不想代入gender war 性别并不是对立的\n听isamoz 讲爱尔兰的克莱尔吉根 走在蓝色的田野上 南极 哇 蓝蓝的 纯净的 高密度的文学\n还想看托宾\n10/14 上午人工智能课见到了熟悉的老师。旁边的同学是很厉害那位。唉。别人是怎么做到正正常常优优雅雅那么优秀的。\n然后去主楼做数据库的实验。下载好慢。后来还出了问题。重装。\n佛了，说chrome内核已经最新了怎么打不开学工系统。原来user-agent switcher得关了\u0026hellip;\n中午吃完石锅拌饭去超市，回来还买了糯米的糖葫芦。\n晚上回来后很难过。为什么别人可以积极地具有攻击性地去追求去生活呢。\n10/12 结果也没做多少事。\n晚上去中关村吃桃山旬野菜村。其实挺温馨的。也一直在笑。\n掉筷子。椰蓉鸡汤的锅底。把刺身还有蛋都下到锅里。生的刺身吃起来像椰果。还拍了合照。\n晚上回来和妈妈打电话。希望自己可以自视更高一点。\n10/11 下午后来果然还是翘了编译原理后两节。\n听剩余价值\n旅行 知识癖\n被曾经的描述，被文化所淹没的地点 文学界的打卡\n10/10 改算法的代码。坐在四楼那个明亮的教室。\n博尔赫斯 富内斯 遗忘的重要性 只有遗忘才能更好地抽象出真正对自己重要的事情\n必读书 不必读\n信息量小 罪恶感\n晚上骑车去深影那，吃了赤焰烤肉。还有和牛炒饭，还有果子。\n回来买了烧仙草。\n然后一直在聊天，一起去洗澡。\n晚上吃燕南的瓜。哇，深情。哇，青梅竹马。哇，意难平。\n10/9 上午操作系统溜了。在旁边听数据分析。熟悉的anaconda.\n向下兼容，找一个自己的子集。物化别人，但并不希望自己被物化。（用硬条件征婚，但也许并不希望被人单纯因为这些外在条件跟自己在一起）\n社会达尔文主义。工具理性在择偶，为什么高知女性被污名化（教育资源，软的无形的影响，育儿优势）？社会刻板印象，男强女弱。\n社会 符号 恋爱也许也是这样\n烟草卡片的故事 那时候我在抄征文投稿 中午的教室超级舒服\n慢慢地，会自然的吧。\n10/7 在教学楼依旧几乎什么都没干。\n下午回来宿舍了。本来准备去西直门的，后来还是算了。\n在超市慢慢地逛。买了黑糖红豆的麻薯。\n喜欢北京的秋天。\n想吃糖炒栗子哇。在路上边走边吃。糖炒的甜味和栗子香都能闻得见。\n想走胡同。想起城南旧事了。\n在寝室呆了会儿。悠闲。突然觉得窝在床上看点剧挺好的，不知道温柔时刻好不好看。富良野的雪。暖炉。森林。nino的灵气。想陷进被窝里，柔柔软软地。\n晚上叫了燕南一起去南门吃水煮鱼。坐在外面。旁边的咖喱屋很香，看起来也很好吃。\n啊悠闲。喜欢坐在外面。\n回来睡了一会儿。\n10/5 昨天晚上睡得很晚。\n在教室里看香水。但是目前嘛，最喜欢的香水是蓝月亮（笑）。\n神奇。今天完全就是秋高气爽的天气了，很不错的天气。\n又想起家里那种感觉了。有烧饼那种炊饭的温馨感，又有阳光下晒着的刚洗完的白衣服的洁净洗衣液味道。怀念啊。\n结果这几天全都在写词法分析的实验报告\u0026hellip;\n想念汤包。想念湿润的阴影的树阴的窗前。想念戴春阳的糖炒栗子。想念和妈妈一起走在街上，随处看见糯米团子的蒸汽和清香就想买着吃。\n晚上有在听说小说的花花传奇。南京的作家。还提到了朱文。\n啊，南京。凝滞不动的哀伤。想起以前去拉贝故居那次，也去了南大南师大，附近的道路，墨绿的树荫，灰色的街道，梅花糕，报刊亭。我的高中三年。\n10/4 下雨了。很冷。\n继续去一层食堂吃绿豆粥和饺子。\n买了极致小盒牛奶和每日坚果。\n今天空气里的湿润的清冷的气息特别熟悉，让我想起了高中的厕所。\n一直写lex的词法分析。yytext不能strcpy也太坑人了。\n晚上吃完饭买了条德芙黑巧克力。边慢慢走边吃。\n就算是晚上，大片厚层的云把天空映得很白很亮。\n10/3 早上睡到很晚。啃了个苹果，去一层食堂吃绿豆粥和饺子。很慢很慢地吃，离门口近，看春雪。\n时代 意志 偶然\n听剩余价值。婚礼 家长的毕业典礼 钻石的巨大溢价 过多被人为赋予价值 与永恒、一生一世挂钩 女生被鼓励与男生竞争的评价体系到达适婚年龄就崩塌了 在亚洲文化里，婚姻是一种package，无法选择要哪个不要哪个 爱情像特洛伊木马，被攻破后之后的一切都无法阻挡\n10/2 看完了你的鸟儿会唱歌。结尾有种混沌的不够畅快的宿醉天明，朦胧的晨雾的感觉，但又是都市的乱糟糟的什么，但也有清明的眸光。片尾曲响起来，高空的风，宿醉之后的跃动，凉快的冷气的夏日，小时候那种感觉。\n继续听剩余价值。\n俄狄浦斯情结，是结果还是原因。社会的压抑通过家庭这一机制作用于个人。\n心理治疗总有一个目标，一个范本。西方的自由主义。然而并不适用于所有人。西方的疗法是否能解决本土问题。\n男性在场的讨论学术，展示知识，但指向权力，显示控场的能力。被彼得罗或尼诺吸引，他们展示了知识可以作为权力的可能性。但知识可以被权力所用，福柯。只能通过爱情这一种方式去接近男性，接近后又需要竭尽全力去摆脱限制。\n学伴。女性是一种性资源，中国男性的焦虑。\n晚上去食堂的路上打电话给妈妈，他们又是去了合肥又是去了福州玩，早知道回家了唉。\n看了一小会儿夜以继日。\nCP文化 能成为ACE的偶像本身应该就是注重异性目光的，所以有刻意去迎合，本身就大概率会是直的。女性被社会驯化，会更关注女性身体，女性身体本身的美丽也可以成为性快感的一部分。看腐，也许也有掩饰自身的性欲，因为女性的性欲往往被视为可耻的。对纯爱的向往，异性恋有时被各种现实条件裹挟。去性化的纯爱。\n10/1 一天都没干劲。很凝滞。\n上午弄了一下VSCO的专业版。\n早知道回家了呢。\n想读一下韩东。竟然也是南京的。苏童、叶兆言、毕飞宇\u0026hellip;作协体制。自由写作真的很少欸。\n不过听了很久剩余价值，倒是很舒服。\nMe2 强迫站队 以行业抵制的方式处理个人历史 不知情权被剥夺（我也选择当鸵鸟） 普拉斯\u0026amp;特德休斯\n寄生虫 燃烧 一个人代表一个阶级去发声，但并没有真正关注个人生命体验 韩国电影追求暴烈、极致的倾向 我们对日韩本土文化实际上是隔离的，反而需要去亲近拥抱欧美文化（我们所接触的日韩文化事实上已经经过了欧美的过滤） 夜以继日 艺术电影讨论阶级问题，可本质上有意无意还是在服务中产阶级\n家庭原教旨主义\n晚上看了血观音。还看了点你的鸟儿会唱歌。\n大家都在看阅兵，走方阵，做志愿，看烟花。举国同庆。我在干什么呢。\n热闹对我来说有点虚无。激情对我来说没有实根。今天倒是重看了遍北京欢迎你，那倒挺温暖。我喜欢具象的印记。\n热热闹闹。和大家一起。会有很多欢笑和美好回忆吧。希望哪一天可以找到平衡。\n2019/9 9/30 一上午课。结果也没看见Z。无从证实了，唉。\n中午和慧慧燕南吃了水煮鱼。\n下午和慧慧去新中关和欧美汇逛街。喝奶茶。吃分米鸡。\n晚上回来玩跳一跳。\n想看血观音。想把你的鸟儿会唱歌看完。\n听剩余价值。谈痛经。痛苦的体验是无意义的，分享痛苦本身也无意义，普遍的解决的办法才是目标。忍痛不应该是一种文化中被默认的美德，不痛是一种权利。是否对这方面医学进展的缓慢显示了对女性的忽视。\n为什么基础科学加起来无法解释传统医学（玄学），它是科学、还是一种文化。\n啊，好喜欢听广播。\n伊凡伊里奇之死。想看托尔斯泰。还想看福楼拜。\n想满心喜悦地拥有一套自己认可的译本，高兴地跳起来，无比珍惜它。\n周围的人在各行各业发光。\n自己要加油啊。想成为可以被依靠被当作某一方面的光源的人。\n这么说有点不厚度，但他人痛苦时确实也是他们最丰富的时候。\n“孰知不向边庭苦，纵死犹闻侠骨香。”\n曹植 与吴季重书\n9/25 开始看《春雪》。以前没发现啊，三岛下笔真的精微。\n9/22 昨天晚上做了一个无比丰富生动的梦。但忘了。\n继续来自习。好难过啊，放眼望过去，也看不见你。你也会有这样的感觉吗。其实只要知道你在就好了，能看见就好了，好像有你在的地方就没那么可怕生硬了。总觉得有相似的气质，怀旧而温和的。不过也有不一样的，吸引我的地方。靠谱的，深蓝的什么。\n中午啃那个香蕉面包。结果今天一天又是废人模式。断断续续用手机看凪的新生活。看吧，看着也会烦吧，不上进的丑女孩耽溺于恋爱感情，对他人的依赖\u0026hellip;好讨厌。\n很早去吃了晚饭，大概四点半的样子。吃了石锅拌饭。\n9/20 下午操作系统和编译原理连着上，令人窒息。下次一定翘。\n我终于把那不勒斯四部曲的第三部看完了。混乱而痛苦。\n晚上又排练合唱。\n9/15 早上在床上写邮件。很晚才下来。\n放假最后一天了。\n傍晚的时候，外面还很亮。粉紫的云，亮蓝的天，窗外有什么彩排的声音传过来。教室里也没几个人。一下子想起高中，晚饭到晚自习之间的那段时间，亮亮的，可以和好友一起穿过天桥去操场看他们踢球。\n晚上我的二苏旧居和寿阳公主梅花香到了。很淡。中药的味道。可能我感冒了闻得不真切。\n想回家。\n“一河星，两岸火，川流满夜灯”\n“金陵酒，秦淮歌，十里粉黛香浓”\n“花相逢，浪相送，江天总无穷”\n桨声灯影啊，婉转悠扬碎在波光里\n无尽的法桐，山岚里的林和塔\n现在好像看科研也没有什么神圣光环加持了。一样的。我不知道哪个是对的选择。怎么找到平衡呢。\n我可能一点进步也没有。还是高中那个稀里糊涂的台灯开着小木桌支着穿着棉袄睡着了清晨醒来码字写新概念稿子的那个我。永远迷茫。睡不踏实，无用的忧郁。\n9/13 上午和慧慧去看了柯南。那家电影院很舒适。\n新加坡。柯南换了导演，观感五光十色的。还是喜欢和平和在一起在关西的氛围。\n下午红叶突然说她也在北京，去海淀黄庄见。\n然后在新中关，欧美汇，食宝街那块乱逛。暗下来的天色，树枝里嵌着球形灯，玻璃幕墙，天色树木灯光。\n去新中关的九龙冰室里坐了会儿。红叶突然发现晚上没地方住了，然后兵荒马乱地联系舍友，决定带她去我们宿舍住一晚。\n后来去欧美汇楼上吃了一家西班牙餐厅。罗勒牛排饭，杂菌温泉蛋，西班牙油条，凯撒沙拉。还挺好吃的。让我有点想起在英国的日子。\n9/12 最近一直在看那不勒斯四部曲的第三部。第三部前面讲莉拉的故事的时候，灰蒙蒙的。和第二部的触感完全不一样。放弃把kindle只放在床上看的原则，带出来随身看之后，感觉可以看很多书看很快的样子。\n没睡好。很困。\n唉，别人闪闪发光的，靠谱的，时刻。我不靠谱，我没有立足之本。我用什么打动人呢？可能性？没人需要没有保障的奇迹吧。\n不是痛苦就可以成为苏格拉底的，主动放弃快乐的猪这个选项，大部分人只能做成痛苦的猪罢了。\n快乐的苏格拉底。这种选项，也是有的。\n最近也在听欧丽娟的红楼梦的课。的确很学院派。我的确还是感情用事的那一种。\n懦。缩减自我。不是人们坏，这只是人们的天性而已，在人际交往中得寸进尺。我就是不愿意吭声那种。不卑不亢，算是目标吧。\n还是喜欢一个人自习。这学期有在一点上有进步，不去辩解。不用去说的。那些重要的事，重要的自我，没必要和别人剖析，如果只是因为他们近。我也做不到主动去触碰别人触碰世界。那就由着自己的步伐就好了。\n晚上春花打了电话过来。很搞笑很无语的事。我在自动扶梯上来来回回上上下下。明天就中秋节了呢。其实还挺想和几个朋友聊聊天的。\n没有选择。想开一点好了，这些都是你的选择，只能成为你的选择。\n9/11 喜欢食堂里的绿豆粥配一盘饺子，喜欢饺子蘸醋和辣椒油，有家的味道，很香。\n为什么大家都有生活的底气呢。我好害怕。天气开始变凉了，走向北门的时候，眼睛也不知道因为看了太久书还是屏幕，有些看不清，人流逆着泛过来，就开始无助。妈妈寄了衣服和葱油饼。\n9/10 量子计算。总之是状态的叠加，上帝掷骰子的概率。\n下完雨的北京很凉快空气也好。本部很适合散步。可惜我只能一个人瞎转悠，也聊不了天。不过后来洗完澡和慧慧一起逛超市。老面包明明就是面包刚刚兴起时的老式面包，之前萌萌跟我说是中式原料，西式做法，不记得了，中西结合的什么\u0026hellip;记了好久。\n晚上和胖胖在我们宿舍聊天。胖胖真好。我好不值得被好朋友宠爱。她们好真诚地愿意发现别人的好。有的时候真的就觉得平平淡淡就是真。雨天坐在床上和好友聊天。洗完澡走条人少的路散步，吹吹晚风。我可以安于现状吗。\n也许Z也只是我的想象而已。任何人都是想象。可是想变得可以更坦然一点，不再是以前想变得游刃有余的傲气，而是希望可以站在那个高度去真正实践自己想要的真诚的温和谦卑。不卑不亢。我好像一直游走在卑和亢两个极端，我靠着这种极度的不平衡来时不时滑到中间点调整自己。好不稳。\n","date":"2020-04-19T21:48:42Z","permalink":"https://imfaye.me/post/dear-diary/","section":"post","tags":["日记"],"title":"一部分的日记(2019.9至2020.4)"},{"categories":["断更"],"contents":"Recover the Smallest Number\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;string\u0026gt; num; bool cmp1(string a, string b) { int la = a.length(), lb = b.length(); string temp; if (la == lb) return a \u0026lt;= b; else if (la \u0026lt; lb) //自己重新定义字符串比较的定义 { if (a.compare(b.substr(0, la)) == 0) { temp = b.substr(la) + a; if (temp \u0026lt;= b) return false; else return true; } else return a \u0026lt;= b; } else if (la \u0026gt; lb) { if (b.compare(a.substr(0, lb)) == 0) { temp = a.substr(lb) + b; if (temp \u0026lt;= a) return true; else return false; } else return a \u0026lt;= b; } } int main() { int n; cin \u0026gt;\u0026gt; n; string s; for (int i = 0; i \u0026lt; n; ++i) { cin \u0026gt;\u0026gt; s; num.push_back(s); } sort(num.begin(), num.end(), cmp1); int len = num.size(); string ans = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; len; ++i) { ans += num[i]; } int pos = 0; bool flag = false; for (int i = 0; i \u0026lt; ans.length(); ++i) { if (ans[i] != \u0026#39;0\u0026#39;) { pos = i; flag = true; break; } } if (flag == false) //要注意全是0的情况！ cout \u0026lt;\u0026lt; \u0026#34;0\u0026#34;; else cout \u0026lt;\u0026lt; ans.substr(pos); return 0; } 若一长一短且短的那个是长的的前缀，重新定义比较的标准。cmp定义了何时a\u0026lt;b，所以自己根据需要的情况直接返回true或false\nsubstr的用法：\ns.substr(5)\n截取从s[5]到结尾\ns.substr(0,5)\n从s[0]开始截取5位\nAC了之后看别人的代码，哭了，我好傻写那么长，直接把比较的标准定义成a+b\u0026lt;b+a就完了\u0026hellip;\nbool cmp0(string a, string b) { return a + b \u0026lt; b + a; } ","date":"2020-04-19T18:13:57Z","permalink":"https://imfaye.me/post/pat-1038/","section":"post","tags":["PAT","算法"],"title":"PAT刷题记录 1038 Recover the Smallest Number"},{"categories":["断更"],"contents":"很有意思的一道贪心\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; double cmax, davg, dall; int n; struct Node { double price; double dis; }sta[505]; bool cmp1(Node a, Node b) { return a.dis \u0026lt; b.dis; } int main() { scanf(\u0026#34;%lf%lf%lf%d\u0026#34;, \u0026amp;cmax, \u0026amp;dall, \u0026amp;davg, \u0026amp;n); for (int i = 0; i \u0026lt; n; ++i) { scanf(\u0026#34;%lf%lf\u0026#34;, \u0026amp;sta[i].price, \u0026amp;sta[i].dis); } sort(sta, sta + n, cmp1); bool flag = false; double far = 0; int ns = 0; int i1 = 0; double min1 = 9999999; double cost = 0; double cnow = 0; double bestprice; while (sta[i1].dis == 0) { if (sta[i1].price \u0026lt; min1) { min1 = sta[i1].price; ns = i1; far = cmax * davg; bestprice = sta[i1].price; } i1++; } if (min1 == 9999999) { printf(\u0026#34;The maximum travel distance = 0.00\u0026#34;); return 0; } while (ns \u0026lt; n) { int i; int u = -1; double min = 9999999; for (i = ns + 1; sta[i].dis \u0026lt;= far \u0026amp;\u0026amp; i \u0026lt; n; ++i) { if (sta[i].price \u0026lt; min) { min = sta[i].price; u = i; if (min \u0026lt; sta[ns].price) //这一步超级重要！！！第一个比当前小的，就可以停了！后面有更小的，用现在贵的油跑更多也是浪费！ break; } } if (u \u0026gt;= 0 \u0026amp;\u0026amp; min \u0026lt; sta[ns].price) //如果下一个比当前便宜，只用加到够跑到下一站的油就够了 { if (cnow \u0026lt; ((sta[u].dis - sta[ns].dis) / davg)) //因为之前会存在多加油的情况，要判断在那个基础上再加油，解释一下:cnow是当前油量(这里是在更新) { cost += ((sta[u].dis - sta[ns].dis) / davg - cnow) * sta[ns].price; cnow = 0; } else { cnow -= (sta[u].dis - sta[ns].dis) / davg; } far = sta[u].dis + cmax * davg; ns = u; } else if (u \u0026gt;= 0 \u0026amp;\u0026amp; min \u0026gt;= sta[ns].price) //如果下一个反而贵，在当前就加满！ { if (far \u0026gt;= dall) //事实证明这一步也很重要，结束的条件并不一定都是u==-1(也就是找不到下一个了)，现在就能去终点，且下一站的油费比现在贵，现在就应该停 { if (cnow \u0026lt; ((dall - sta[ns].dis) / davg)) { cost += ((dall - sta[ns].dis) / davg - cnow) * sta[ns].price; } printf(\u0026#34;%.2f\u0026#34;, cost); break; } cost += (cmax - cnow) * sta[ns].price; cnow = cmax - (sta[u].dis - sta[ns].dis) / davg; far = sta[u].dis + cmax * davg; ns = u; } else if (u == -1 \u0026amp;\u0026amp; far \u0026gt;= dall) { if (cnow \u0026lt; ((dall - sta[ns].dis) / davg)) { cost += ((dall - sta[ns].dis) / davg - cnow) * sta[ns].price; } printf(\u0026#34;%.2f\u0026#34;, cost); break; } else if (u == -1 \u0026amp;\u0026amp; far \u0026lt; dall) { printf(\u0026#34;The maximum travel distance = %.2f\u0026#34;, far); break; } } return 0; } 下一个加油站的选择，不是可到达范围里油费最便宜的，而是第一个比当前加油站油费便宜的！这一步自己刚开始一直是错的orz，典型的想当然\n如果不能找到更便宜的下一站，这一站要加满。\n还有一个点是判断结束的条件，现在可到达终点且之后的都贵，就可以停了。\n","date":"2020-04-19T18:03:34Z","permalink":"https://imfaye.me/post/pat-1033/","section":"post","tags":["PAT","算法"],"title":"PAT刷题记录 1033 To Fill or Not to Fill"},{"categories":["无情笔记"],"contents":"CH1 语言能力与语言系统 易境性 动物交流的特点：在场。在场与直接经验。人类不必在场传递经验，关键在语言。通过语言传递知识与经验，不必在场。\n还原生成性 基于类推原则的还原生成能力。从单词到句子，是一种创造性行为。乔姆斯基：语言是有限规则和单位生成无限的句子。\n还原生成能力：通过有限的句子还原出有限的规则和单位，并通过这些单位生成无限的句子。\n人类语言学习的自然还原能力。只要存在一定数量的句子，不需要人为切分，就可以还原出有限的规则和单位，生产无限的句子。(我们不必看过全部的句子，自然通过对比就实现切分)(小孩是如何自然学习语法的。成人所总结的语法未必是正确的。所以我们希望学习方法论。)\n动物语言能力。呼叫或姿态大多是整体，句子有限。\n任意性 语言能力在特定文化中的运用形成语言系统。核心部分：\n基于任意性的符号编码能力 基于类推性的还原生成能力 区分两种基本单位的能力(体现为符号的两层性) 编码能力：能在任意性原则上把所指和能指结合成符号的能力\n任意性：词的语音形式A和意义B的关系是任意的\n动物语言的形式与意义之间任意性成分很少。\n我们的符号系统里加入的非任意性的成分，不是语言学符号，是象征。\n反对任意性原则的学说可以称为音义关联说。证据：拟声说，右文说。\n拟声不是自然语音的必要条件。声音的临摹，语序的临摹，这两种临摹方式是有限的。\n右文说的本质：引申\n任意性，支持材料：\n同一个概念在不同的语言中声音不一样 语言中有大量的虚词、抽象词无法象声 两层性 自然语言有两种最基本的单位：\n音位\n区别意义的单位\n语素\n表达意义的单位\n两层性的文化功能在于用最少的区别性表达尽可能多的符号。\n两层性意味着可以用有限的手段(主要是语音)产生无限的符号形式(和有限的符号产生无限的符号组合不一样)\n人类自然语音从低到高有音位层、音节层、语素层、词汇层、词组层、句子层。音位系统是区别意义层，语素系统是表达意义层。\n一般认为汉语中有27个音质音位。\n语音是人类社会的一部分。是我们先天还是后天的能力。即使有先天的语言能力，必须有后天的交流环境，语言系统。语言学习关键期。\nCH2 语言和思维 ","date":"2020-04-05T16:44:14Z","permalink":"https://imfaye.me/post/linguistics/","section":"post","tags":["语言学"],"title":"语言学概论 笔记"},{"categories":["无情笔记"],"contents":"the kernel is structured to use device-driver modules.\ndevice driver为IO子系统提供了统一设备访问接口\n两个趋势：接口日益标准化，设备多样性\nIO 硬件 port\nbus\ncontroller\nController usually have registers, where device driver places commands, addresses, and data to write, or read data from registers after command execution. Data-in register, data-out register, status register, control register\n设备有地址\nDirect I/O instructions\nMemory-mapped I/O 内存映射IO\n设备控制寄存器 被映射到 处理器的地址空间\nEspecially for large address spaces (graphics)\nIO端口有4种寄存器：\nstatus control data-in data-out Techniques for Performing I/O\nProgrammed I/O Interrupt-driven I/O Direct Memory Access (DMA) polling 轮询 控制器通过状态寄存器的busy bit显示其状态\n主机通过命令寄存器中的command-ready bit表示其意愿\nbusy-waiting / polling 主机不断读状态寄存器直到忙位被清除\nPolling can happen in 3 instruction cycles, Read status, logical-and to extract status bit, branch if not zero\ninterrupts Interrupt-request line\nInterrupt handler receives interrupts. Maskable to ignore or delay some interrupts\nInterrupt vector to dispatch interrupt to correct handler\n中断向量：中断处理程序的内存地址\n计算机设备比向量内地址多。interrupt chaining 中断向量内的每个元素都指向中断处理程序列表的头\n实现了中断优先级\nInterrupt mechanism also used for exceptions\nGood uses: system calls, page fault\nUsed for time-sensitive processing, frequent, must be fast.\nDMA Requires DMA controller, a special-purpose processor.\nBypasses CPU to transfer data directly between I/O device and memory.\nHost writes a DMA command block into memory.\nCPU writes the address of this command block to the DMA controller.\nDMA controller operates the memory bus directly, placing address on the bus to perform transfers.\nWhen the entire transfer is finished, the DMA controller interrupts the CPU.\nHandshaking between the DMA controller and the device controller:\n​\tperformed via a pair of wires called DMA-request and DMA-acknowledge.\nDMA控制器抓住内存总线时，CPU暂时不能访问主存，但可以访问一级或二级高速缓存中的数据项。\n周期挪用cycle stealing可能放慢CPU计算，但数据传输工作交给DMA控制器改善整体性能\nDVMA (direct virtual memory access) can perform a transfer between two memory-mapped devices without the intervention of the CPU or the use of main memory. 直接实现两个内存映射设备之间的传输，无需CPU的干涉或使用主存\nIO应用接口 设备驱动程序层device-driver layer为内核IO子系统隐藏设备控制器之间的差异\nBroadly I/O devices can be grouped by the OS into\nblock IO character-stream IO memory-mapped file access network sockets OS存在后门(escape / back door)，允许应用程序将任何命令透明地传输到设备控制器\nUnix ioctl()\n块与字符设备 Block devices include disk drives\nCommands include read(), write(), seek()\nRaw I/O, direct I/O, or file-system access\nMemory-mapped file access possible\nDMA\nCharacter devices include keyboards, mice, serial ports\nCommands include get(), put()\n网络设备 The socket interface, Linux, Unix and Windows\nIncludes select functionality: manages a set of sockets\nclocks and timers Provide current time, elapsed time, timer\nProgrammable interval timer used for timings, periodic interrupts.\nBlocking I/O and Nonblocking I/O Blocking - process suspended until I/O completed\nNonblocking - I/O call returns as much as available\nAsynchronous - process runs while I/O executes 不必等待IO完成就可立即返回\nKernel I/O Subsystem IO scheduling 为每个设备维护一个请求队列\nbuffering 保存两个设备之间 或 设备和应用程序之间 所传输数据的内存区域\ncaching 高速缓存是可以保留数据副本的高速存储器\nbuffer可能是数据的唯一副本，而cache只是提供了一个 驻留在其他地方的数据 在高速存储上的一个副本\n有时同一内存区域可同时用作cache和buffer\nSpooling假脱机 \u0026amp; Device reservation Spooling - hold output for a device\nDevice reservation( 预约) - provides exclusive access to a device\nerror handling Most return an error number or code when I/O request fails.\nSystem error logs hold problem reports\nIO protection 所有IO指令为特权指令\nIO必须通过system call执行\n内核数据结构 Kernel keeps state information for I/O components, including open file tables, network connections, character device state.\nMany complex data structures to track buffers, memory allocation, “dirty” blocks.\nSome use object-oriented methods and message passing to implement I/O.\n把IO操作转换成硬件操作 ","date":"2020-02-28T13:13:24Z","permalink":"https://imfaye.me/post/os13/","section":"post","tags":["操作系统","大明湖畔的专业课"],"title":"操作系统笔记 CH13 I/O Systems"},{"categories":["无情笔记"],"contents":"磁盘 扇区0是最外面柱面的第一个磁道的第一个扇区。映射先按磁道内扇区顺序，再按柱面内磁道顺序，最后按从外到内的柱面顺序来排序的。\nHead crash results from disk head making contact with the disk surface. Cannot be repaired, the entire disk must be replaced.\nDisks can be removable\nHost controller in computer uses bus to talk to disk controller built into drive or storage array.\nThe disk controller operates the disk-drive hardware to carry out the command.\nDisk controllers have a built-in cache. Data transfer at the disk drive happens between the cache and the disk surface. Data transfer to the host, at fast electronic speeds, occurs between the cache and the host controller.\n磁带 长久，存储大量数据。慢\n磁盘结构 Disk drives are addressed as large 1-dimensional arrays of logical blocks, where the logical block is the smallest unit of transfer.\nLow-level formatting(低级格式化) creates logical blocks on physical media.\nConstant Linear Velocity ( 常数线性周转率)\nthe density of bits per track is uniform\nCD-ROM, DVD-ROM\nConstant Angular Velocity ( 常数角周转率)\nthe density of bits decreases from inner tracks to outer tracks\nhard disk\ndisk attachment 计算机访问磁盘存储两种方式\n通过IO端口(或主机附属存储)\n小系统采用这种方法\n通过分布式文件系统DFS的远程主机，称为网络附属存储\nHost-attached storage Is accessed through I/O ports talking to I/O busses\nI/O directed to bus ID, device ID, logical unit (LUN)\nNetwork-Attached Storage (NAS) 客户通过远程进程调用接口访问NAS\nUNIX中的NFS，windows中的CIFS(Common Internet File System)\nRPCs are carried via TCP or UDP on IP network.\nThe NAS unit is usually implemented as a RAID array with software that implements the RPC interface.\nNew iSCSI protocol uses IP network protocol to carry the SCSI protocol. Remotely attaching to devices (blocks)\nStorage Area Network (SAN) 服务器与存储单元之间的私有网络(采用存储协议而非网络协议)\n灵活\nCommon in large storage environments.\nMultiple hosts attached to multiple storage arrays – flexible\nSAN is one or more storage arrays Connected to one or more Fiber Channel switches\nHosts also attach to the switches.\nStorage made available via LUN Masking from specific arrays to specific servers.\ndisk scheduling Minimize seek time\nOS maintains queue of requests, per disk or device.\ncontrollers have small buffers and can manage a queue of I/O requests.\nFSFC SSTF Shortest Seek Time First starvation\nSCAN / elevator 到达另一端时，磁头改变方向\nC-SCAN 当磁头移到另一端时，会马上返回磁盘开始。将柱面当成环链\nLOOK 磁头只移动到一个方向上最远的请求为止\nC-LOOK 磁盘调度算法的选择 SSTF is common and has a natural appeal\nSCAN and C-SCAN对磁盘负荷大的系统执行较好，不会有starvation\nRequests for disk service can be influenced by the file-allocation method.\nThe disk-scheduling algorithm should be written as a separate module of the operating system, allowing it to be replaced with a different algorithm if necessary.\nEither SSTF or LOOK is a reasonable choice for the default algorithm.\n磁盘管理 磁盘格式化 disk formatting 低级格式化/物理格式化：将磁盘分成扇区以便磁盘控制器能读能写。为每个扇区采用特殊的数据结构。The data structure typically consists of a header(sector #), a data area, and a trailer(ECC, error correction code) 扇区通常512B，但可选\nOS需要将自己的数据结构记录在磁盘上\n将磁盘分为由一个或多个柱面组成的分区。将每个分区作为一个逻辑磁盘。\nLogical formatting逻辑格式化\n创建文件系统\n为了提高效率，大多数OS将块集中到一大块，称作簇(cluster)。磁盘IO通过块完成，文件系统IO通过簇完成\nraw disk生磁盘：将磁盘分区作为一个逻辑块的大顺序数组，没有任何文件系统数据结构\nraw disk可用作swap space\n对该数组的IO称作raw IO\n有些数据库系统比较喜欢raw IO\nboot block 引导块 bootstrap程序应找到磁盘上的操作系统内核，装入内存，并转到起始地址，从而开始OS的执行\nbootstrap保存在ROM中。不过大多数OS只在ROM中保留bootstrap loader: 进一步从磁盘上调入更完整的bootstrap程序\n完整的bootstrap程序在磁盘的启动块(boot block)上，启动块位于磁盘的固定位置。\n拥有启动分区的磁盘称为boot disk或system disk\n启动扇区 MBR master boot record . Besides boot code, the MBR contains a partition table listing the partitions for the hard disk and a flag indicating which partition the system is to be booted from.\n启动ROM中的代码引导磁盘控制器将启动块读入到内存(此时尚未装入设备驱动程序)\n硬盘分为一个或多个分区，一个分区为boot partition，包含OS和设备驱动程序。该分区的第一个扇区既是boot sector\nbad blocks Controller calculates the ECC and finds the sector is bad. 控制器计算ECC\nAn unrecoverable hard error results in lost data.\n对于简单磁盘：坏块可手工处理\n对于复杂磁盘：\n​\t控制器维护一个磁盘坏块链表，控制器可用备用块来逻辑地替换坏块 sector sparing(forwarding)\n​\tsector slipping\n","date":"2020-02-28T13:12:24Z","permalink":"https://imfaye.me/post/os12/","section":"post","tags":["操作系统","大明湖畔的专业课"],"title":"操作系统笔记 CH12 Mass-Storage Structure"},{"categories":["无情笔记"],"contents":"文件系统结构 磁盘特点：可以原地重写，可以直接访问任意一块。\n内存和磁盘之间的IO以块为单位。每块为一个或多个扇区。扇区通常为512B\nFile system resides on secondary storage (disks) OS通过文件系统存储、定位、提取数据\nIO control 最底层\n由device driver 和 Interrupt handlers组成\n实现内存和磁盘之间的信息传输。\ndevice driver可作为翻译器。输入是高层命令，输出是底层的、硬件特定的命令。命令用于控制hardware controller\ndevice driver控制一类设备\nbasic file system\nIssue generic commands to the appropriate device driver to read and write physical blocks on the disk.\nfile-organization module\n将逻辑块地址 转换成 物理块地址\n也包括空闲空间管理器\nlogical file system\n管理metadata，元数据包括文件系统所有结构数据，而不包括实际数据\n管理目录结构\n通过FCB((inodes in UNIX))维护文件结构\n负责保护和安全\nLayering useful for reducing complexity and redundancy, but adds overhead and can decrease performance.\n绝大多数OS支持多个文件系统\nUNIX使用UFS\n标准的Linux文件系统是extende file system\n文件系统实现 每个卷的boot control block：从该卷引导OS需要的信息。如果没有OS，该块为空，通常为卷的第一块。UFS称之为boot block，NTFS称之为partition boot sector\n每个卷的volume control blcok：包括卷(或分区)的详细信息，如分区的块数，块的大小\u0026hellip;UFS称之为superblock，NTFS中它存在master file table中\n每个文件系统的目录结构用来组织文件。UFS中包含文件名和相关的inode号，NTFS中它存储在master file table中\n每个文件的FCB。UFS中是inode，NTFS存在master file table中，每个文件占一行\nIn-Memory File System Structures 一个内存中的mount table(partition table)\n一个内存中的director structure cache\nsystem-wide open-file table: 包括每个打开文件的FCB副本\nper-process open-file table: Contains a pointer to the appropriate entry in the system-wide open-file table.\nbuffers hold data blocks from secondary storage.\n对于访问打开文件表的索引：UNIX称之为file descriptor，Windows称之为file handle. 只要文件没有关闭，所有文件操作都是通过打开文件表来进行的\npartitions and mounting 分区和安装 一个disk可以分为多个partition，一个partition可以横跨多个disk(作为RAID的一种形式比较合适)\n分区可以是\nraw 没有文件系统 cooked 含有文件系统 引导信息能保存在多个分区中，通常为一组有序块，并作为镜像文件读入内存\nboot loader知道位于引导区的多个文件系统和多个操作系统，一旦装入，它可以引导位于磁盘上的一个操作系统。磁盘可以有多个分区，每个分区包含不同类型的文件系统和不同的操作系统。\nroot partiton包括操作系统内核或其他系统文件，在引导时装入内存。\n内存中有Mount table – containing information about file systems that has been mounted.\nvirtual file system (VFS) Virtual file system (VFS) on most OSes, including Unix, use object-oriented techniques to implement the file system. 用户甚至可以访问位于网络上的操作系统\nVFS allows the same system call interface (the API) to be used for different types of file systems.\nImplements vnodes which hold inodes or network file details.\nThe API is to the VFS interface, rather than any specific type of file system.\n多个VFS接口的实现可以共存在同一台机器上\nvnode表示位于整个网络范围内唯一的文件\nLinux has four object types: inode, file, superblock, dentry\nVFS defines a set of operations on the objects that must be implemented.\n目录实现 linear list 线性列表 linear search time费时\nsorted list允许binary search\na balanced tree\nhash table decreases directory search time\n需要处理collision(两个文件名哈希到相同的位置)：chained-overflow\nDifficulties: fixed size, hash function\n分配方法 how disk blocks are allocated for files\nContiguous Allocation 连续分配 每个文件在磁盘上占有一组连续的块\n访问连续分配文件所需寻道数最少\n用第一块的磁盘地址和连续块的数量来定义\nsequential and direct access\nBest performance in most cases\n问题\nDifficult to find space for a new file: First-fit, best-fit External fragmentation compaction off-line (downtime) or on-line Extent-Based Systems, a modified contiguous allocation scheme 当空间不够时，另一块被称为扩展的连续空间会添加到原来的文件分配中\nLinked Allocation 链接分配 每个文件是磁盘块的链表\n目录包括文件第一块的指针和最后一块的指针。每一块都有下一块的指针。\n没有外部碎片\n只要有空闲块，文件就可以增大\nDisadvantages: 不能随机访问，指针需要空间，不可靠\n对于指针需要空间，解决办法是将多个块组成簇(cluster)，代价是增加了内部碎片\nFAT(file-allocation table)文件分配表 used by MS-DOS and OS/2\n对FAT采用缓存\n支持直接访问\nIndexed Allocation 索引分配 每个文件都有索引块，是一个磁盘块地址的数组\n目录条目包括索引块的地址\n支持直接访问\n没有外部碎片\n索引块应该多大\nlinked scheme\n将多个索引块链接起来\ntwo-level index\ncombined scheme\nUNIX采用\n性能 contiguous great for sequential and random\nlinked good for sequential, not random\ncombine contiguous allocation with indexed allocation by using contiguous allocation for small files (up to three or four blocks), automatically switching to an indexed allocation if the file grows large.\nfree-space management 文件系统需要维护free-space list记录空闲磁盘空间(不一定是链表)\nbit map / bit vector 每块用一位表示。空闲-1，已分配-0\n查找第一个和n个连续空闲块简单高效\nBit map requires extra space.\nEasy to get contiguous files space.\nlinked list 链表 将所有空闲块用链表链接\n将指向第一空闲块的指针缓存在内存\nCannot get contiguous space easily.\ngrouping 将n个空闲块的地址存在第一个空闲块里。(前n-1确实为空，最后一块包含另外n个空闲块的地址)\n可以找到大量空闲块\ncounting 记录第一块的地址和紧跟第一块的连续的空闲块的数量n\ncan be stored in a balanced tree for efficiency\n","date":"2020-02-28T13:11:24Z","permalink":"https://imfaye.me/post/os11/","section":"post","tags":["操作系统","大明湖畔的专业课"],"title":"操作系统笔记 CH11 File-System Implementation"},{"categories":["无情笔记"],"contents":"file concept 文件：记录在外存上的 相关信息的 具有名称的 集合，逻辑内存的最小分配单元\n通常，文件表示程序和数据\nfree form or may be formatted rigidly\nfile attributes name: human-readable identifier: a unique number, non-human-readable name type location size protection time, date and user identification 文件的信息存在directory中，directory也存在外存上\nA directory entry consists of the file\u0026rsquo;s name and its unique id. The id in turn locates the other file attributes.\nfile operations 6个基本文件操作：\ncreate\nwrite\nwrite pointer\nread\nread pointer\nA per-process current-file-position pointer\nreposition\nfile seek, not need I/O\ndelete\nrelease file space, erase directory entry\ntruncate\nreset length to 0, release file space\n只删除内容，保留属性\n基本操作可以组合成其他操作\nMost file operations involve searching the directory for the entry associated with the named file\n首次使用文件时，使用系统调用open()\nOS维护一个包含所有打开文件的信息表(open-file table)。当需要一个文件操作时，通过该表的一个索引指定文件，无需搜索。文件不再使用时，进程可关闭它，OS从open-file table删除这一条目。系统调用create和delete操作的是关闭文件，而不是打开文件。\n系统调用open()返回一个指向open-file table中一个条目的指针。通过使用该指针，而不是真实文件名称，进行所有IO操作。also accept access mode information, such as create, read-only, read-write, append-only, etc.\nclose(Fi), move the content of entry Fi in open-file table to directory structure on disk.\n多进程可能同时打开同一文件。OS采用两级内部表。\nProcess open-file table, a per-process table\n该进程所使用的文件信息\n单个进程表的每个条目相应地指向整个系统的打开文件表\nSystem open-file table, a system-wide table\n包含进程无关信息(如文件在磁盘上的位置，访问日期和文件大小)\n一旦一个进程打开文件，System open-file table会增加相应条目，当另一个进程执行调用open()，在其Process open-file table增加一个条目，并指向System open-file table相应条目\n每个文件有一个open count，记录多少进程打开了该文件。当open count=0，该文件条目可删除。\n每个打开文件有如下信息：\nfile pointer\npointer to last read/write location\n对每个进程唯一\nfile-open count\ndisk location of file\naccess rights\n每个进程用一个访问模式打开文件\n保存在单个进程打开文件表中\n文件锁(file locks) shared lock: 多个进程并发获取\nexclusive lock: 只有一个进程可以获取\n加锁机制：\nmandatory强制：一个进程获得锁，阻止其他进程访问已加锁的文件。access is denied depending on locks held and requested. \u0026ndash; Windows OS.\nadvisory建议：processes can find status of locks and decide what to do. \u0026ndash; Unix OS.\nfile types 实现文件类型的常用技术：在文件名称内包含类型。名称可分为两部分：name , extension\nSome OS, each file has a type, and a creator attribute containing the name of the program that created it.\nUNIX, a magic number stored at the beginning of some files to indicate roughly the type of the file.\naccess methods Criteria for File Organization: Rapid access, Ease of update, Economy of storage, Simple maintenance, Reliability\nsequential access 顺序访问 基于文件的磁带模型。不仅适用于顺序访问设备，也适用于随机访问设备\ndirect access 直接访问 文件由固定长度的逻辑记录组成。基于文件的磁盘模型。可立即访问大量信息。数据库常采用这种类型的文件。\n提供的是相对块号。\n对直接访问文件，可容易地模拟顺序访问。反过来很低效。\n其他访问方式 通常涉及创建索引\ndirectory structure 有时需要在一个磁盘上装多种文件系统\nDisk can be subdivided into partitions.\nDisk or partition can be used：\n​\traw, without a file system, e.g. swap space\n​\tformatted with a file system\nVolume: Entity containing file system\nEach volume containing file system also tracks that file system\u0026rsquo;s info in device directory or volume table of contents.\nDisks or partitions can be RAID protected against failure.\ndirectory可看作符号表，将 文件名 转换成 目录条目\nBoth the directory structure and the files reside on disk.\nSingle-Level Directory 所有文件包含在同一目录中\n必须有唯一名称\nnaming problem , grouping problem\nTwo-Level Directory 为每个用户创建独立目录\nA master file directory(主文件目录MFD) and one user file directory(用户文件目录UFD) for each user.\nUFD内文件名唯一即可\nNo grouping capability\nFile sharing怎么解决\nPath name. defined by a user name and a file name. Special user directory, containing system files. Search path, the sequence of directories searched. Tree-Structured Directories 树有根目录，系统内的每个文件都有唯一路径名\nOne bit in each entry defines the entry as a file(0) or as a subdirectory(1).\nGrouping Capability\n每个进程有 Current directory (working directory) 当前目录 In accounting file, a pointer/the name of the user\u0026rsquo;s initial directory. Copied to a local variable for this user.\nAbsolute path name: 从根开始\nrelative path name: 从当前目录开始\n创建子目录/新文件在当前目录下完成\nDeleting a subdirectory\n​\tdeleting a empty directory. \u0026ndash; MS-DOS 目录不为空不能删除\n​\tdeleting all files and subdirectories that it contains.\u0026ndash; UNIX 所有该目录的文件和子目录可删除\nAcyclic-Graph Directories 无环图 树状结构禁止共享文件和目录\n注意这里是共享文件而不是文件复制，共享文件任何改变为其他用户可见\nWays implementing shared files and subdirectories:\n​\tCreate a new directory entry, called a link. \u0026ndash; UNIX link, a pointer to another file or subdirectory. Resolve the link – follow pointer to locate the file.\n​\tduplicate all information about shared files in all sharing directories. 问题：维护一致性\n当用户删除文件时就删除，会留下dangling pointer\n​\t对于link: Deletion of a link need not affectt he original file. Deletion of the file entry, leaving the links dangling.\n​\t对于duplication: File-reference list, Backpointers. 为每个文件保留一个引用列表或引用计数Backpointers, so we can delete all pointers.\nGeneral Graph Directory 允许环存在\n为避免无限循环：强制限制在搜索时所访问目录的次数\n何时可删除？因为有环，就算不存在引用，其引用计数也可能不为0，可能存在自我引用。解决办法：Garbage collection: The first pass, traversing the entire file system, marking everything that can be accessed. The second pass, collects everything that is not marked onto a list of free space.\nHow to avoid cycles? Allow only links to file not subdirectories. Every time a new link is added use a cycle detection algorithm. A simpler algorithm, bypass links during directory traversal.\nfile system mounting 文件系统安装 OS需要知道 设备名称 和 安装点(mount point)\nOS验证设备是否包含一个有效文件系统(通过device driver读入设备目录，验证目录是否具有期望格式)\nOS在其目录结构记录下：一个文件系统已安装在给定安装点上\nSystems impose semantics to clarify functionality.\nfile sharing 多用户需要共享文件\nSharing may be done through a protection scheme.\nMore file and directory attributes are needed: File / directory owner; File / directory user, access rights; File / directory user groups, access rights\nUser IDs identify users, allowing permissions and protections to be per-user. Group IDs allow users to be in groups, permitting group access rights.\nremote file system 远程文件系统 通过程序(如ftp)在机器之间进行文件的人工传输\ndistributed file systems (DFS)\n远程目录可从本机上直接访问\nmuch tighter integration\nvia the World Wide Web(WWW)\nA browser is needed. uses anonymous file exchange.\nClient-server model allows clients to mount remote file systems from servers.\nClient and user-on-client identification is insecure or complicated.\n​\tclient can be specified by a network name or other identifier, such as an IP address, Can be spoofed or imitated.\n​\tSecure authentication via encrypted keys. Ensuring compatibility of the client and server.\nNFS: standard UNIX client-server file sharing protocol\nCIFS(Common Internet File System): standard Windows protocol, uses active directory\nStandard operating system file calls are translated into remote calls远程调用\nDistributed Information Systems Providing unified access to the information needed for remote computing.\nDNS (domain name system) provides host-name-to-network-address translations for entire internet.\nNIS (network information service), yellow pages黄页, centralizes storage of user names, host names, printer information, and the like.\nLDAP (lightweight directory-access protocol), used by industry as a secure distributed naming mechanism. secure single sign-on\nFailure Modes 故障模式 Remote file systems add new failure modes, due to network failure, server failure.\nRecovery from failure can involve state information about status状态信息 of each remote request.\nStateless protocols such as NFS V3 include all information in each request, allowing easy recovery but less security.\nIn NFS V4, it is made stateful\nConsistency Semantics 一致性语义 描述多用户同时访问共享文件时的语义。规定了一个用户所修改的数据何时对另一用户可见。\n由于延迟，不适合类似进程同步那些复杂算法\nAFS (Andrew File System) implemented complex remote file sharing semantics\nserver记录client的动作\nWhen a client changes a file, the server notifies other clients with a call back promise technique\n一个用户对打开文件的写不能立即被打开同一文件的其他用户看见。一旦文件关闭，其修改只能被以后打开的会话所见。\n多个用户允许对自己的映像进行并发(没有延迟)的读写操作\nUFS (Unix file system) implements\n一个文件与单个物理映射相关联，该映射作为互斥资源访问。修改立即可见。竞争导致用户进程延迟。\nImmutable shared files, declared by its creator. Read-only. 不可修改\nprotection 高层功能可以用系统程序调用低层系统调用实现。保护可以只在低层提供。\nMode of access: read, write, execute\n为每个文件和目录增加一个访问控制列表ACL(Access-control list)，给定每个用户名及其允许访问的类型\n三种用户类型:\nowner group universe(public): all other users in the system 每个域三个位:RWX. 需要9个位\n","date":"2020-02-28T13:10:24Z","permalink":"https://imfaye.me/post/os10/","section":"post","tags":["操作系统","大明湖畔的专业课"],"title":"操作系统笔记 CH10 File-System Interface"},{"categories":["无情笔记"],"contents":"background CH8的内存管理方案需要将整个进程放入内存，动态载入只能减轻这一限制\nCode needs to be in memory to execute, but entire program rarely used.\nexecute partially-loaded program\n程序不受现有物理内存大小限制，可以为virtual address space编写程序 更多程序可以同时执行，CPU利用率增加，而响应时间、周转时间不增加 载入或交换程序所需IO变少，用户程序运行更快 Virtual memory – separation of user logical memory from physical memory.\n动态内存分配，堆向上增长；子程序调用，栈向下增长。包括洞的虚拟地址空间是稀地址空间。\nEnables sparse address spaces with holes left for growth, dynamically linked libraries, etc.\nVirtual memory allows files and memory to be shared by two or more processes through page sharing.\n虚拟内存实现：\ndemand paging demand segmentation demand paging 按需调页 Lazy swapper: never swaps a page into memory unless that page will be needed.\nswapper对整个进程进行操作，pager只对进程的单个页进行操作\n页表条目，valid-invalid bit: valid-合法也在内存 invalid-无效(不在逻辑地址空间) 或 有效但在磁盘\npure demand paging: 只有在需要时才将页调入内存\n单个指令可能访问多个页的内存(一页指令，其他页数据)，一个指令可能产生多个page fault. 不过由于locality of reference, 按需调页的性能还算合理。\n按需调页的硬件支持：\nPage table with valid-Invalid bit Secondary memory (swap device with swap space) 请求调页的关键要求是能够在页错误后instruction restart\n如果页错误在获取操作数时，再次获取指令，再次译码指令，再次获取操作数。\n一个指令可能改变多个不同位置。若源和目的块有重叠，源块可能已修改，不能简单地再次执行。(微码计算试图访问两块的两端；临时寄存器保存覆盖位置的值)\nEAT = (1– p) * memory access time + p * page fault service time\npage fault service time = page fault overhead+[ swap page out ]+swap page in+restart overhead\n处理页错误中断和重新启动进程可以通过仔细编码降低开销\nEAT与页错误率直接相关\n与文件无关的页需要使用交换空间\nCopy-on-Write 写时复制 fork()使用写时复制技术\n父子进程开始时共享同一页面。这些页面标记为写时复制页(只有可能修改的页需要标记)。如果任一进程对页进行写，创建一个共享页的副本。\nCOW allows more efficient process creation as only modified pages are copied.\nfree pages are allocated from a pool of free pages. 采用按需填零(zero-fill-on-demand)技术分配这些页，需要分配前先填零，因此清除了以前的内容。\nvfork()，不采用copy-on-write，vfork()将父进程挂起，子进程使用父进程的地址空间。如果子进程修改父进程地址空间的任何页， 父进程重启时可见。主要用于子进程被创建后立即调用exec()的情况。比较高效。用于实现UNIX命令行shell的接口。\npage replacement Use modify bit (dirty bit) to reduce overhead of page transfers. 不修改的话不需要写回磁盘\nPage replacement completes separation between logical memory and physical memory.\nframe-allocation algorithm\npage replacement algorithm\nreference string: 内存的引用序列\nFIFO Belady\u0026rsquo;s anomaly: 页错误率可能会随着所分配的帧数的增加而增加\nOPT/MIN 置换最长时间不会使用的页\n未来知识\nLRU 最长时间没有使用的页\nBy the principle of locality, this should be the page least likely to be referenced in the near future.\nAssociates with each page the time of that page’s last use.\n两种可行实现：\ncounter\n每个页表项关联一个使用时间域。对每次引用，计数器增加。置换具有最小时间的页。\nstack\n没引用一个页，页就从栈中删除并放在顶部\nNo search for replacement, LRU page is at the bottom.\nLRU Approximation Algorithms LRU needs special hardware and still slow.所以用近似算法\n页表每项都关联一个reference bit, 每引用一个页(读or写)，引用位被硬件置1\nReference bit algorithm When page is referenced, the bit is set to 1 by the hardware.\nReplace the one which is 0 (if one exists).\nProblem ：We do not know the order.\nAdditional-reference-bits algorithm Keep an 8-bit byte for each page in a table in memory.\n规定时间间隔里记录引用位\nAt regular intervals, a timer interrupts, OS shifts the reference bit for each page into the high-order bit of its 8- bit byte, shifting the other bits right by 1 bit and discarding the low-order bit.\n将这8位看作无符号整数，置换具有最小值的页\nSecond chance / Clock Basic algorithm: FIFO\n循环队列，指针向前移动直到找到一个引用位为0的页，在向前移动时，清除引用位。\n如果所有位均已设置，会遍历整个队列。成了FIFO\nEnhanced Second-Chance Algorithm (reference bit, modify bit)\n(0,0)最好 (0,1) (1,0) (1,1)\n降低IO\nCounting-based page replacement 每个页保留一个用于记录引用次数的计数器。\nLFU: replaces page with the smallest count\nMFU: page with the smallest count was probably just brought in and has yet to be used.\npage allocation 帧分配 分配至少最少数量的帧。必须有足够的帧容纳所有单个指令所引用的页。\n每个进程的帧的最少数量由体系结构决定，最大数量由可用物理内存的数量决定。\nfixed allocation\n高低优先级一样处理\nwhen a page fault occurs, one of the pages of that process must be replaced. \u0026ndash; Local replacement\n固定分配必须局部置换(置换自己进程里的页)\nequal allocation\nn个进程之间分配m个帧，每个m/n帧\nproportional allocation\n根据进程大小比例地分配内存\n进程pi的虚拟内存大小si\na i = s i /S * m\npriority allocation\nUse a proportional allocation scheme using priorities rather than size, or on a combination of size and priority.\nLocal replacement: select for replacement one of its frames\n​\t分配每个进程的帧的数量不变\nGlobal replacement: select for replacement a frame from a process with lower priority number\n​\t易于实现。更好的系统吞吐量，常用。\n​\tOS keeps list of free frames.\n​\t进程不能控制其页错误率(受其他进程调页行为影响)\nthrashing 系统颠簸 thrashing: 频繁的页调度行为\n如果一个进程在换页上用的时间多于执行时间，这个进程就在颠簸\nCPU调度程序发现CPU使用率降低，增加多道程序程度\u0026hellip;更多页错误，CPU使用率更低\n颠簸时，为了增加CPU使用率和降低系统颠簸，必须降低多道程序的程度\n采用局部置换，一个进程颠簸不会使其他进程颠簸\nWhy does thrashing occur? Σ locality size \u0026gt; total memory size\nusing a local (or priority) replacement algorithm, Can limit the effect of thrashing.\n为了防止颠簸，必须提供进程所需的足够多的帧。\nLocality: a set of pages that are actively used together. Process migrates from one locality to another. Localities may overlap.\nWorking-Set Model 工作集合模型 基于局部性假设\n参数Δ定义working-set window：a fixed number of page references\nWorking Set: the set of pages in the most recent Δ page references.\nWSS i (working set size of Process P i ) : (varies in time) the number of pages in Working Set of process P i .\n工作集合的精度与Δ的选择有关，太小不能包含整个局部，太大包含多个局部\n总的帧需求量 D =Σ WSS i 总的需求大于帧的数量，会出现颠簸\nOS跟踪每个进程的工作集合，如果D \u0026gt; m，暂停一个进程，该进程的页被写出，且其帧可分配给其他进程\n通过固定定时中断(interval timer)和引用位(reference bit)可以近似模拟工作集合模型\nPage-Fault Frequency Scheme(PPF) 页错误频率 为所期望的页错误率设置上限和下限。超过上限，为进程分配更多的帧；低于下限，从该进程中移走帧。\n如果页错误率增加且没有可用帧，必须选择一个进程暂停，可将释放的帧分配给具有高页错误率的进程\n","date":"2020-02-28T13:09:24Z","permalink":"https://imfaye.me/post/os9/","section":"post","tags":["操作系统","大明湖畔的专业课"],"title":"操作系统笔记 CH9 Virtual Memory"},{"categories":["无情笔记"],"contents":"background 基本硬件 CPU可直接访问的存储器只有 内存 和 处理器内的寄存器\n​\tCPU内置寄存器可在一个CPU时钟周期内完成访问，对于寄存器中的内容，CPU可以在一个周期内解析并执行多个指令\n​\t对于内存，访存可能需要多个时钟周期。没有数据时，要暂停(stall)\n协调速度差异，在CPU和内存之间，增加高速缓存cache\ninstruction-execution cycle: Fetch an instruction, decode instruction, fetch operands, execute, store results back into memory\n为了确保正确操作，需要保护内存。\n每个进程有独立空间。两个寄存器：\nbase register: 最小的合法物理地址 limit register: 范围的大小 CPU硬件对user mode产生的每一个地址与寄存器的地址进行比较，实现内存空间的保护。\n只有OS可以通过特殊的特权指令加载base register和limit register\n地址绑定 address binding 进程在执行时可以在磁盘和内存之间移动，在磁盘上等待调入内存以便执行的进程形成input queue\n许多系统允许用户进程放在物理内存的任意位置，用户进程开始地址不必为0\n源程序中的地址用符号表示，compiler将symbolic address绑定到relocatable address(如从本模块开始的第14字节)，linker或loader将可重定位地址绑定成absolute address。每次绑定都是从一个地址空间到另一个的映射。\n将指令与数据绑定到内存地址有几种情况：\ncompile time\n编译时就知道进程将在内存中的驻留地址，可以生成absolute code\n如果将来地址发生变化，必须重新编译代码\nload time\n编译时不知道。编译器生成relocatable code\n绑定延迟到加载时\n如果开始地址发生变化，只需重新加载用户代码引入改变值\nexecution time\n进程在执行时可以从一个内存段移到另一个内存段\n绑定延迟到执行时\n需要硬件(如base and limit registers)\nlogical vs. physical address space logical address: CPU生成的地址，virtual adderss\nphysical address: 内存单元看到的地址，即加载到memory-address register的地址\ncompile-time和load-time的address binding生成相同的逻辑地址和物理地址，但execution-time生成不同的，这种情况称逻辑地址为virtual address\nlogical address space: 程序所生成的所有逻辑地址的集合\nphysical address space: 与这些逻辑地址相对应的物理地址的集合\n运行时完成从虚拟到物理的地址映射的硬件：MMU(memory-management unit)\nrelocation register: 用户进程所生成的地址送交内存前，加上relocation register的值\n用户程序绝不会看到真正的物理地址(execution-binding只发生在它作为内存地址引用时(比如间接加载和存储时))\n用户程序处理逻辑地址，内存映射硬件将逻辑地址映射为物理地址\nswapping 进程可以暂时从内存swap到backing store上，需要再次执行时再调入内存\nbacking store通常是fast disk，容纳所有用户的memory images，提供对这些内存镜像的直接访问。\nready queue包括在backing store和在内存中准备运行的所有进程\n如果绑定是在汇编时或加载时所定的，一个交换出的进程必须交换回原来的内存空间，如果绑定是在运行是所定，可以移到不同的位置\nroll in, roll out: 交换策略的变种被用在基于优先级的调度算法中\nDispatcher is called whenever the CPU scheduler decides to execute a process\n交换系统的context switch time比较长\n为了有效使用CPU，需要每个进程的执行时间比交换时间长\n交换时间主要是transfer time, 和所交换的内存空间成正比(进程10MB，备份存储是40MBps的硬盘，传入或传出：10MB/40MBps)\n如果要换出进程，必须确保该进程完全处于空闲状态\nsolution to 待处理IO(pending IO)\n不能换出有待处理IO的进程 IO操作的执行只能使用OS buffers. double buffering 交换空间通常作为磁盘的一整块，且独立于文件系统。\n标准交换使用不多，一些交换的变种得到应用。(不如通常不执行交换，许多进程运行且内存吃紧，开始交换，若系统负荷降低，停止交换)\ncontiguous memory allocation 内存通常分为两部分，一部分驻留OS，一部分用于用户进程。操作系统通常位于低内存。\n连续内存分配：每个进程位于一个连续的内存区域\n内存映射和保护 relocation-register scheme:\nrelocatio/base register\nlimit register\n每个逻辑地址必须小于limit register\nMMU动态地将逻辑地址加上relocation register的值后映射成物理地址\nrelocation-register scheme允许OS动态改变。如果某驱动程序不常用，不必再内存保存数据和代码，transient kernel code根据需要调入或调出，使用这类代码可以在程序运行时动态改变OS大小\nmemory allocation fixed partitioning (MFT)\n多道程序的程度受分区数限制\ninternal fragmentation: 进程所分配的内存比所需要大\nequal-size partitions\nunequal-size partitions\nqueue for each partition\nvariable partitioning (MVT)\nvariable length and number\nhole: a block of available memory\nOS维护一个表，记录哪些内存可用/已被占用\nrecaim的时候如果新孔与其他孔相邻，将这些孔合并成大孔\n从一组可用孔选择一个：fisrst-fit, best-fit, worst-fit\nfisrt fit: 50% rule N个可分配快，0.5N个块为外部碎片，1/3内存不可用\nfirst和best在时间和利用空间好于worst，first和best利用空间差不多，first更快。\nexternal fragmentation: 所有可用内存之和可以满足要求，但并不连续\n解决外部碎片：\n紧缩(compaction)\n把所有空闲空间合并成一整块\n紧缩仅在重定位是动态并在运行时可采用\n允许物理地址空间非连续\n分页/分段\npaging 分页 允许进程物理地址空间非连续\n帧(frame): 物理内存划分为固定大小的块\n页(page): 逻辑内存分为同样大小的块\nbacking store也划分为固定大小的块(block)\n页大小由硬件决定，通常为2的幂(power of 2)，512B~16MB\nWhen a process is to be executed, its pages are loaded into any available memory frames from the blocks.\nOS为每个进程维护一个page table, contains the frame location for each page in the process, page table used to translate logical to physical addresse\n有internal fragmentation(进程要求内存大小不是页大小的整数倍)\n由CPU生成的地址分为两部分：page number(used as an index into a page table), page offset\n逻辑地址页号位数：进程可以有多少页决定\n物理地址页号位数：帧数决定\n分页特定：用户视角的内存与物理内存分离。用户程序将内存作为一整块处理，只包括这一个进程。逻辑地址到物理地址的映射由硬件完成，用户不知道。\n分页的硬件支持 每个进程一个页表。页表的指针与其他寄存器的值存入PCB。启动进程时，首先装入用户寄存器。\n\u0026lt;256 entries, 页表可作为一组专用寄存器实现；大的页表存在内存中。\nPTBR(Page-table base register) PTLR(Page-table length register) 装入或修改页表寄存器的指令是特权级的\n访问一个字节需要2次访存(一次页表条目，一次字节)\nTLB 解决这个问题：TLB(translation look-aside buffer / associative memory)\nThe given page number is compared with all keys simultaneously.\npage # 和 frame #\na hit\na miss\nthe page number is used to index the process page table\n有的TLB允许有些条目固定下来 wired down(e.g. entries for kernel code)\n有的TLB在在每个TLB条目中保存ASID(address-space identifier)，可唯一地标识进程，为进程提供地址空间保护，允许TLB同时包含多个不同进程的条目\nEAT(Effective Access Time) hit ratio: 页号在TLB中被查找到的百分比率\n内存保护 分页环境下，内存保护通过与每个帧相关联的保护位实现。这些位保存在页表里。\nRW bit: read-write or read-only\nvalid-invalid bit: 在不在进程的逻辑地址空间中。有点浪费，所以有时用PTLR看页表长度\nAny violations result in a trap to the kernel.\n页表结构 层次页表 Hierarchical forward-mapped page table\ne.g. VAX(virtual address extension)体系结构支持一种两层分页的变种\n页表项长度是页面的地址。页表大小=页面个数*页表项长度 。\n哈希页表 Hashed Page Tables Common in address spaces \u0026gt; 32 bits\n哈希页表每一条目包括一个链表的元素，每个元素3个域：1虚拟页码 2所映射的帧号 3指向链表中下一元素的指针\n群集页表(clustered page table)类似于哈希页表，不过每一条目包括多页，对于稀疏地址空间有用\n反向页表 Inverted Page Table Rather than each process having a page table and keeping track of all possible logical pages, track all physical pages.\nOne entry for each real frame of memory.\n每个条目包含 保存在真正内存位置的页的虚拟地址 和 拥有该页的进程的信息\n整个系统只有一个页表。\nOften requires an address-space identifier (ASID) stored in each entry of the page table.\nEnsures the mapping of a logical page for a particular process to the corresponding physical page frame.\n\u0026lt; process-id, page-number, offset \u0026gt;\n减少存储空间，但增加了查找时间。\n可以通过哈希页表将查找限制在较少的条目中。访问哈希表时先访问TLB\n反向页表实现共享内存困难。共享内存通常作为被映射到一个物理地址的多虚拟地址实现。而反向页表，每个物理页只有一个虚拟页条目。\n解决办法：允许页表包含one mapping of a virtual address to the shared physical address\n分段 segmentation 用户视角的内存管理方案\n每个段有名称和长度。地址指定了段名称和段偏移。\n分段：用户通过两个量指定地址，段名称和段偏移；分页：用户只指定一个地址，该地址通过硬件分为页码和偏移，对用户透明\n\u0026lt;segment-number, offset\u0026gt;\n二维用户定义地址映射为一维物理地址，通过段表(segment table)实现，段表每个条目有segment base和segment limit\nSTBR(segment-table base register): points to the segment table’s location in memory\nSTLR(segment-table limit register): indicates number of segments used by a program\n","date":"2020-02-28T13:08:24Z","permalink":"https://imfaye.me/post/os8/","section":"post","tags":["操作系统","大明湖畔的专业课"],"title":"操作系统笔记 CH8 Main Memory"},{"categories":["无情笔记"],"contents":"deadlock characteristics necessary conditions 4个条件同时满足，引起死锁：\nmutual exclusion\n至少有一个资源处于非共享模式，一次只能有一个进程使用\nhold and wait\n占有至少一个资源，等待另一为其他进程所占资源\nno preemption\n资源不能被抢占\ncircular wait\nresource-allocation graph request edge : Pi-\u0026gt;Rj\nassignment edge : Rj-\u0026gt;Pi\n申请边只用指向矩形，但分配边必须从某个原点开始\n资源分配图有环是死锁的必要条件。若每类资源只有一个实例，含环是充分必要条件。若同类资源数\u0026gt;1,不一定有死锁。\nmethods for handling deadlocks 1.预防或避免死锁\n2.允许进入死锁，检测并恢复\n3.忽视这个问题(为多数OS所用)\ndeadlock prevention: 确保至少一个必要条件不成立，通过限制如何申请资源\ndeadlock avoidance: 事先得到进程申请和使用资源的额外信息，系统可确定对于一个申请，进程是否等待(申请允许还是延迟)，考虑可用、已分配、进程将来申请和释放的资源\ndeadlock prevention 确保4个必要条件至少1个不成立\nmutual exclusion\n通常不通过这个条件\u0026hellip;\nhold and wait\n每个进程在执行前申请并获得所有资源\n进程在没有资源时才可申请资源(申请更多资源前，先释放已分配的资源)\n缺点:1.资源利用率低 2.starvation\nno preemption\n如果一个进程占有资源并申请另一个不能立即分配的资源，其现在已分配的资源都可被抢占(被隐式释放)。\n进程申请资源时，不可用也不被其他等待进程占有时，等待\n常应用于状态可以保存恢复的资源，如CPU寄存器和内存，不适用于打印机和磁带驱动器等。\ncircular wait\n对所有资源类型进行完全排序。每个进程只按递增顺序申请资源。(只能申请编号比它大的)\ndeadlock avoidance 死锁避免比死锁预防要求低\ndeadlock prevention 低设备使用率和吞吐率\na system is in a safe state only if there exists a safe sequence\nresource-allocation-graph algorithm 增加claim edge(需求边)，虚线\n当进程Pi开始执行时，所有需求边必须先处于资源分配图。(可放宽为只要与Pi有关的需求边)\n只有在申请边Pi-\u0026gt;Rj变成分配边Rj-\u0026gt;Pi，而不会出现环时，才允许申请。环存在是unsafe state\ncycle-detection algorithm\nbanker\u0026rsquo;s algorithm 自己看书做题去 P247\ndeadlock detection 不采用prevention和avoidance，应提供检查是否出现死锁\u0026amp;恢复算法。\n每种资源类型单个实例 wait-for graph: Pi等待Pj释放一个Pi需要的资源\nPi-\u0026gt;Pj iff 资源分配图中 Pi-\u0026gt;Rq, Rq-\u0026gt;Pj\n图中有环 \u0026lt;-\u0026gt; 死锁\n每种资源类型多个实例 detection algorithm\n资源图消边法 PPT P45 + 看橘\nrecovery from deadlock process termination 不管哪种进程终止方法，系统都会收回分配给终止进程的所有资源\n终止所有死锁进程 一次终止一个，调用死锁检测，直到取消死锁循环 resource preemption select a victim: which resources and which processes are to be preempted 代价因素 cost factors\nrollback: 抢占资源后对进程做什么安排 roll back to some safe state. simplest: total rollback\nstarvation: 如何保证资源总是从一个进程抢占 在代价因素中加上回滚次数\n","date":"2020-02-28T13:07:24Z","permalink":"https://imfaye.me/post/os7/","section":"post","tags":["操作系统","大明湖畔的专业课"],"title":"操作系统笔记 CH7 Deadlocks"},{"categories":["无情笔记"],"contents":"race condition: 多个进程并发访问和操作同一数据，结果与访问顺序有关\ncritical section critical section: 进程可能改变共同变量，更新表，写文件的代码段\nentry section: 实现请求进入其临界区的代码段\n临界区问题三要求：\nmutual exclusion 同一时间临界区存在一个进程 progress 如果一个进程想进入临界区，它终将成功 bounded waiting 从一个进程做出进入临界区的请求，到该请求被允许，其他进程允许进入临界区的次数有限 kernel code可能会出现race condition\n两种方法: 1.preemptive kernel 2.non-preemptive kernel 抢占内核更适合real-time programming,且更responsive\nPeterson\u0026rsquo;s solution software-based solution to the critical section problem 基于软件\nsynchronization hardware 基于硬件\n特殊硬件指令 原子地(不可中断)检查、修改、交换字内容\ndisable interrupt, a lock\nTestAndSet()\n返回的是原来的值，进入过testandset，之后就变成true\n实现有限等待互斥：\n","date":"2020-02-28T13:06:24Z","permalink":"https://imfaye.me/post/os6/","section":"post","tags":["操作系统","大明湖畔的专业课"],"title":"操作系统笔记 CH6 Process Synchronization"},{"categories":["无情笔记"],"contents":"dispatcher: gives control of the CPU to the process selected by the short-term scheduler;\ndispatch latency\nscheduling criteria CPU utilization,\nthroughput:\n单位时间完成进程数量\nturnaround time:\nsubmission to completion\nwaiting time:\nsum of time spent in the ready queue就绪队列\nresponse time:\nsubmission to first response(time it takes to start responding, not the time it takes to output the response)\nscheduling algorithm FCFS first-come, first-served\nnon-preemptive\n等待时间较长\nconvoy effect(短进程跟在长进程后面)\nSJF shortest-job-first\nshortest next CPU burst\n常用于长期调度，短期调度可预测next CPU burst\nexponential average\npreemptive/non-preemptive\npreemptive SJF : shortest-remaining-time-first scheduling\npriority scheduling algorithm\nSJF is a special case of it\npriority can be defined internally or externally\npreemptive/non-preemptive(非抢占优先级调度只是将优先级高的新进程加到ready queue的头部)\n主要问题是indefinite blocking/starvation\n低优先级无穷等待问题解决方法: aging(逐渐增加等待很久进程的优先级)\nRR round-robin\nespecially for time-sharing system\n时间片(time quantum/time slice)\n所需时间小，自动释放CPU，所需时间大，时间片到timer会产生中断\n平均等待时间较长\npreemptive\n时间片很大：FCFS；时间片很小：processor sharing(仿佛都有自己的处理器，速度为1/n)\n时间片应比context-switch time大，也不应太大\nmultilevel queue scheduling algorithm\nforeground(interactive); background(batch) 前台进程更高优先级。前台可能RR，后台可能FCFS\nready queue划分成多个队列，一个进程被永久分配到一个队列，每个队列有自己的调度算法\n队列间常采用fixed-priority preemptive scheduling, 或在队列间划分时间片，每个队列有一定CPU时间\nmultilevel feedback queue schedling algorithm\n允许进程在队列之间移动\n使用过多CPU时间，移到低优先级队列。所以IO bound \u0026amp; interactive processes(使用CPU时间少)会被留在高优先级队列\n较低优先级队列等待时间过长的进程也会被转移到更高优先级队列，prevent starvation\n看例子P172\n最通用的CPU调度算法\nHRRN highest response-ratio next 高响应比优先\nnon-preemptive\nPPT P51\nmulti-processor scheduling 非对称多处理(asymmetric multiprocessing),一个处理器处理调度，IO，其他系统活动；其余处理器处理用户代码\nSMP symmetric multiprocessing 对称多处理：每个处理器自我调度，许多OS支持SMP\nprocessor affinity: 使缓存无效或重构的代价太高，所以尽量使一个进程在同一个处理器上允许。不能保证进程不移动:soft affinity，否则hard affinity\nload balancing: 将工作负载平均地分配到SMP所有处理器上。load balancing只对拥有自己私有可执行进程的处理器必要(大部分时候都有私有)\n​\tpush migration: a specific task周期检查每个处理器上的负载，如果不平衡，push processes from overloaded to idle processor\n​\tpull migration: an idle processor pulls a waiting task from a busy processor\nmulticore processors: PPT P61\nSMT: symmetric multithreading 提供多个逻辑处理器实现多线程并发 hyperthreading. 每个逻辑处理器负责自己的中断处理。\nthread scheduling 对在内核级支持线程的系统而言，系统调度的是内核线程而不是进程。用户线程由线程库管理。\nPCS: process-contention-scope 线程库调度用户级线程到一个有效的LWP上(CPU竞争发生在属于相同进程的线程之间) ,local scheduling\nSCS: system-contention-scope 调度哪个内核线程到CPU(CPU竞争发生在系统的所有线程中)。一对一模型只用使用SCS ,global scheduling\n实例 书P178\nalgorithm evaluation analytic evaluation: 产生一个公式或数字\ndeterministic evaluation: 计算在给定负荷下算法的性能\nqueueing-network-analysis:\nsimulation模拟 trace tape\n","date":"2020-02-28T13:05:24Z","permalink":"https://imfaye.me/post/os5/","section":"post","tags":["操作系统","大明湖畔的专业课"],"title":"操作系统笔记 CH5 CPU Scheduling"},{"categories":["无情笔记"],"contents":"Dispatching is referred to as a thread. Resource of ownership is referred to as a process or task.\n对进程的swapping和termination都牵扯它所有线程\n线程是CPU使用的基本单位。由thread ID, program counter, register set, stack组成\nmultithreading models User threads, supported above the kernel and are managed without kernel support.\nKernel threads, supported and managed directly by the operating system.\nmany-to-one\none-to-one\n一个线程阻塞，另一个还能运行\n并发。开销大。\nwindows, linux, solaris 9\nmany-to-many\n用户线程映射到数量相同或更少的内核线程\nWhen a thread performs a blocking system call, the kernel can schedule another thread for execution.\ntwo-level model:\nthread libraries 两种方法实现：1 在用户空间提供一个没有内核支持的库 2 由OS直接支持的内核级的库\nPOSIX Pthreads\nPortable Operating System Interface of UNIX\nReferred to user-level library\nWin32 threads\nkernel-level threads library\nJava threads\nprovides support at the language level for the creation and management of threads.\n两种创建线程的方法\nextending thread class define a class that implements the Runnable interface thread issues The fork() and exec() system calls thread cancellation Asynchronous cancellation 异步取消：立即取消\nDeferred cancellation 延迟取消：不断检查是否该终止\nsignal handling A signal is used in UNIX systems to notify a process that a particular event has occurred.\nSynchronous signal: illegal memory access, division by 0.\nAsynchronously signal: terminating a process with specific keystrokes, Ctrl+C ，由运行进程之外的事产生\ntwo possible handlers:\na user-defined signal handler a default signal handler, which is run by the kernel 同步信号送到需要发到产生它的线程\nthread pools 优点：1 快 2 限制可用线程数量\nthread-specific data Thread-specific data allows each thread to have its own copy of data (Thread-local storage (TLS) ).\nTLS visible across function invocations\nscheduler activation Scheduler activation \u0026ndash; one scheme for communication between the user-thread library and the kernel.\nprovides upcalls, the kernel inform an application about certain events.\nupcall handlers must run on a LWP.\n当一个应用线程要阻塞，内核向应用程序发upcall，分配一个新LWP给应用线程，应用线程在这个LWP上运行upcall handler\n当阻塞线程等待事件发生，内核向线程库发另一个upcall， kernel allocates a new LWP or preempt one of the user threads to run the upcall handler for this event.\nOS examples windows XP threads one-to-one\nETHREAD (in kernel space), KTHREAD (in kernel space), TEB (in user space)\nLinux threads - tasks clone() system call\n","date":"2020-02-28T13:04:24Z","permalink":"https://imfaye.me/post/os4/","section":"post","tags":["操作系统","大明湖畔的专业课"],"title":"操作系统笔记 CH4 Threads"},{"categories":["无情笔记"],"contents":"process concepts batch system: job; time-sharing system: program/task\nProgram is passive entity stored on disk (executable file), process is active.\na process includes\ntext section(program code) data section(global variables) heap(动态分配的内存) process stack(临时数据) function parameters, return value return addresses local variables current activity(represented by program counter and registers) process state\nnew: being created running: instructions are being executed waiting/limiting: waiting for some event ready: waiting to be assigned to a processor terminated/halted: finished execution 一次只有一个进程可以在一个处理器上运行，但多个进程可处于就绪或等待状态。\n**PCB(**process control block): process state \u0026amp; program counter \u0026amp; CPU registers(中断时要保存程序计数器和CPU寄存器) \u0026amp; CPU-scheduling information \u0026amp; memory-management information \u0026amp; accounting information \u0026amp; I/O status information\n栈是运行时的单位，而堆是存储时的单位。 堆中存的是对象。栈中存的是基本数据类型和堆中对象的引用。\na program becomes a process when an executable file is loaded into memory\n两个进程可以和同一个程序相关，虽然text section一样，但data,heap,stack sections不同。\nprocess scheduling process scheduler selects an available process for program execution on CPU\nscheduling queues job queue作业队列：进程进入系统时，被加入作业队列，该队列包括系统中的所有进程\nready queue就绪队列：驻留在内存的ready或waiting进程\ndevice queue设备队列：等待特点I/O设备的进程列表。每个设备都有自己的设备队列\nqueueing diagram\nschedulers long-term / job scheduler: select processes from the pool and load them into memory\nshort-term / CPU scheduler: select processes that are ready and allocates CPU to one of them\n短期调度频繁，长期调度（和新进程创建时间间隔有关）控制degree of multiprogramming(内存中的进程数量)\n长期调度需仔细选择，一个包含I/O bound process和CPU bound process的组合。全是IO bound, 就绪队列几乎为空，短期调度无事可做；全是CPU bound，IO等待队列几乎为空。\n有些系统可能没有长期调度。有些OS如分时系统，引入medium-term scheduler, 将进程从内存（CPU竞争）中移出，降低multiprogramming设计难度。 swapping . The process is swapped out, and is later swapped in, by the medium-term scheduler.\nswapped/suspended processes；2 new states: swapped waiting, swapped ready\ncontext switch context is represented in PCB\ncontext switch(上下文切换): performing a state save of the current process and a state restore of a different process\n发生中断时，系统需要保存当前运行在CPU中进程的上下文，上下文通过PCB表示。state save; state restore\nContext-switch time is pure overhead\nContext-switch times dependent on hardware support\noperations on process process creation: reasons: Submission of a batch job, User logs on, provide a service, Process creates another process assign a PID, allocate space, initialize PCB, resource sharing.\nWhen a process is created, it obtains initialization data that may be passed along from the parent process to the child process.\nUNIX examples\n​\tsystem call fork creates new process\n​\tsystem call exec used after a fork to replace the child process’ memory space with a new program.\ncreate-process system call\nprocess identifier PID\n创建子进程时，可能从操作系统直接获得资源，也可能只从其父进程那获得资源\nprocess termination Process executes last statement and asks the operating system to delete it (via exit).\nParent may terminate execution of its children processes (via abort). cascading termination\ninterprocess communication(IPC) independent / cooperating processes\nshared memory\n速度快 memory speed\nunbounded/bounded buffer\nmessage passing\n交换少量数据， 不必避免冲突，易于实现。通常通过system call实现，内核介入的时间消耗。\n分布式环境中有用\ncommunication link\n直接通信(direct communication-naming): 每个进程必须明确地命名通信的接收者或发送者。每对进程之间只有一个线路，一个线路只与两个进程有关。symmetry/asymmetry in addressing\n间接通信(indirect): 通过mailbox或port。两个进程共享一个邮箱时，建立通信线路。一个线路可以与多个进程关联。每个线路对应一个邮箱。进程/OS可以拥有邮箱。拥有邮箱的进程只能收。\nblocking or unblocking(synchronous or asynchronous)\n当send和receive都阻塞时，发送者和接收者之间有一个集合点(rendezvous)\nbuffering: zero/bounded/unbounded capacity\nmessage system with no/automatic buffering\nexamples of IPC 实例\nPOSIX\nshmget,shmat,shmdt,\nMach\nMicrokernel OS\nMach communication is message based\nmailbox , called port in Mach\nEach task gets two mailboxes at creation\u0026ndash; Kernel and Notify\nKernel uses the kernel mailbox to communicate with task, and sends notification of event occurrences to the Notify port.\nkernel mailbox, notify mailbox\nmsg_send, msg_receive, msg_rpc(remote procedure call远程过程调用)\n为分布式系统设计\nLPC(local procedure call) in windows\n位于同一机器的两进程通信\nport object\n2 types of ports\nconnection ports\n为所有进程可见\ncommunication ports\n两种端口消息传递技术\n小消息：\n端口队列(message queue)作为中间存储，将消息从一个进程复制到另一个进程\n大消息：\nsection object\n不能马上响应: callback mechanism 允许异步消息传递\ncommunication in client-server systems socket\nA socket is defined as an endpoint for communication.\nAll ports below 1024 are considered well known;When a client process initiates a request for a connection, it is assigned a port (greater than 1024) by its host computer.\n一对通信进程需使用一对socket，一个进程一个\nsocket由IP+端口号组成\n所有连接必须唯一\n远程过程调用RPC remote procedure call\n用于通过网络连接系统\nEach message is addressed to an RPC daemon listening to a port on the remote system.\nStubs – client-side proxy for the actual procedure on the server.\nThe client-side stub locates port on the server and marshals the parameters, transmits a message to the server.\nThe server-side stub receives this message, unpacks the marshaled parameters, and performs the procedure on the server. Return values are passed back to the client.\nmachine-independent representation of data, external data representation (XDR).\n客户端提供存根(stub)，对每个独立的远程过程都有一个stub。存根位于服务器的端口，编组(marshal)参数。XDR\n远程方法调用RMI remote method invocation\nRPC的java版\nRMI allows a Java program on one machine to invoke a method on a remote object.\n对象位于不同JVM上，就认为是远程的\n存根(stub)和骨干(skeleton).存根为远程对象的代理，驻留在客户机上，存根将包发给服务器，远程对象的骨干会接受它\n参数传递规则：\n编排参数是本地对象：对象串行化(object serialization) 复制传递； 编排参数是远程对象：引用传递 reference 本地对象作为参数传给远程对象：实现接口 java.io.Serialization ","date":"2020-02-28T13:03:24Z","permalink":"https://imfaye.me/post/os3/","section":"post","tags":["操作系统","大明湖畔的专业课"],"title":"操作系统笔记 CH3 Process"},{"categories":["无情笔记"],"contents":"UI CLI command-line / command interpreter\nimplemented in kernel (MS-DOS)\nby systems program (Windows / UNIX)\nmultiple flavors implemented – shells UNIX / Linux\nlinux shell : shell: 带形参的批命令文件\nbatch interface\nGUI graphical user interface\ndesktop, icon, Xerox PARC\nsystem calls Programming interface to the services provided by the OS\nwritten in high-level language\nMostly accessed by programs via a high-level Application Program Interface (API) rather than direct system call use.\nmost common API:\nWin32 API POSIX API: for UNIX, Linux, and Mac OS X Java API: for JVM A programmer accesses an API via a library of code provided by the operating system. (e.g. libc )\nthe run-time support system provides a system-call interface that serves as the link to system calls.\nsystem call parameter passing 3 methods:\ntypes of system call process control\ndump memory if error, Debugger for determining bugs, single step execution, Locks for managing access to shared data between processes\nfile manipulation\ndevice manipulation\ninformation maintenance\ncommunications\nmessage passing model\nthrough an interprocess-communication facility (IPC) provided by OS\nshared memory passing\nprocess use map memory system call to gain access to regions of memory owned by other processes.\nsystem prorams file management\nstatus information: Some systems implement a registry, used to store and retrieve configuration information.\nfile modification\nprogramming-language support\nprogram loading and execution\ncommunications\nsystem utilities/application programs:\nbackground services: Launch at boot time. Run in user context not kernel context. Known as services, subsystems, daemons\nOS design and implementation 策略policy: 决定做什么，可能随时间位置改变，对资源分配很重要\n机制mechanism: 决定怎么做，系统更需要通用机制\nThe separation of policy from mechanism allows maximum flexibility if policy decisions are to be changed later. 微内核把机制与策略的区分利用到极致。\nEmulation can allow an OS to run on non-native hardware.\n用高级语言编写， OS更易移植，降低速度，增加存储要求\nbottleneck routines can be identified. replaced with assembly-language equivalents.\nOS structure simple structure\nMS-DOS\n没被仔细划分成模块，没有很好区分接口和层次\nUNIX\n由内核和系统程序组成\nlayered approach\nthe bottom layer (layer 0) is the hardware, the highest (layer N) is the user interface\n每层利用低层提供功能实现\nadvantage: contruction, debugging, design, implementation\ndifficulty: disk driver \u0026amp; memory-management routines, disk driver \u0026amp; CPU scheduler\nless efficient\nmicrokernels\nMach\nmicrokernel contains only essential functions\nmemory management CPU scheduling communications 微内核主要功能：使 客户程序 和 运行在用户空间的各种服务 之间进行通信 message passing\nMach, Tru64 UNIX, Mac OS X kernel, QNX\n由于系统功能总开销增加而导致系统性能下降\nmodules\nMany modern operating systems implement loadable kernel modules.\nThe kernel has a set of core components and dynamically links in additional services via modules, either at boot time or during run time.\n允许内核提供核心服务，也能动态地实现特定功能\n类似分层，但更灵活，任一模块可调用其他任何模块。\n类似微内核，核心模块只有核心功能及其他模块加载和通信的相关信息。更高效，因为模块无需调用消息传递来通信。\nhybrid systems:\n​\tlinux \u0026amp; solaris: monolithic, modular\n​\twindows: monolithic, plus microkernel for different subsystem personalities, run as user-mode processes, dynamically loadable kernel modules\nMac OS X: 分层，其中一层包括Mach微内核\nvirtual machines takes the layered approach to its logical conclusion\nIt treats hardware and the operating system kernel as though they were all hardware.\nThe operating system creates the illusion of multiple processes, each executing on its own processor with its own (virtual) memory.\nby CPU scheduling by virtual memory virtualization: a technology that allows operating systems to run as applications within other operating systems. VMM(virtual machine Manager)\nEmulation used when source CPU type different from target type. When computer language not compiled to native code – Interpretation\nadvantage: protection of system resources, solving system compatibility problem.\n虚拟机软件允许在kernel mode(因为它自己就是操作系统)，但虚拟机自身只能允许在user mode\nvirtual kernel mode 和 virtual user mode 都允许在 physical user mode\n真正机器上user mode到kernel mode的切换，也必须在虚拟机上引起从virtual user mode到virtual kernel mode的切换\nJVM consists of\nclass loader\nclass verifier\nJava interpreter\nsoftware module that interprets the bytecodes one at a time\nJust-In-Time (JIT) compilers turns the architecture-neutral bytecodes into native machine language for the host computer. JVM automatically manages memory by performing garbage collection.\nOS generation 对于某个特定的计算场所，必须配置configure和生成generate系统：SYSGEN\ngeneration methods:\n​\t可完全重新编译\n​\t或系统描述可用来创建表\n​\t或完全table-driven(绝大多数现代OS是这样),选择发生在执行时而不是编译连接时。\nsystem boot booting: starting a computer by loading the kernel\nBootstrap program (bootstrap loader): small piece of code stored in ROM. locates the kernel, loads it into memory, and starts its execution.\ntwo step:\nbootstrap loader\nfetches the boot program from boot block into memory to execute.\nboot program\nloads the entire OS into memory and begin its execution\n","date":"2020-02-28T13:01:24Z","permalink":"https://imfaye.me/post/os2/","section":"post","tags":["操作系统","大明湖畔的专业课"],"title":"操作系统笔记 CH2 OS structures"},{"categories":["无情笔记"],"contents":"What OS do 操作系统是管理计算机硬件的程序\ncomputer system: hardware, operating system, application programs, users\n​\thardware: CPU, memory, I/O devices\nuser view services provided by OS:\nprogram development (editors and debuggers)\nprogram execution\naccess to IO devices\ncontrolled access to files\nsystem access\nerror detection and response\ninternal and external hardware errors\nmemory error, device failure\nsoftware errors\narithmetic overflow, accesss forbidden memory locations\n外中断: interruption 与当前运行程序无关的事件\n内中断: exception / trap 非法操作码，地址越界，算术溢出，缺页，专门陷入指令\u0026hellip;\naccounting\ncollect statistics monitor performance system view resource allocator, control program\ndefining OS kernel, one program running at all times\n系统软件。程序模块的集合。组织和管理计算机的软硬件资源。\ncomputer-system organization computer startup: bootsrap program: stored in ROM/EEPROM, AKA firmware\n硬件\u0026amp;固件：\n​\tA hardware has a physical entity\n​\tA hardware needs a program to run. A firmware is a program itself.\n​\tA hardware cannot operate without a firmware. A firmware operates on a hardware.\nOS starts executing the first process, and waits for some event to occur:\nan interrupt from the hardware\nsending a signal to CPU by way of the system bus\nan interrupt from the software\nexecuting a system call\ncomputer-system operation device controller informs CPU that it has finishd its operation by causing an interrupt\ninterrupt:\n​\tinterrupt vector(中断向量): the staring address of all the interrupt service routines(中断服务程序).\na trap is a software-generated interrupt caused either by an error or a user request\nOS is interrupt-driven\nstorage structure storage hierarchy\n​\tspeed, cost, volatility\nIO structure programmed IO\nIO module performs the action\ninterrupt-driven IO\nprocessor is interrupted when IO module ready to exchange data\nprocessor is free to do other work\nconsume a lot of processor time\nwe need system call \u0026amp; device-status table\nsynchronous IO\nAfter I/O starts, control returns to user program only upon I/O completion.\nasychronous IO\nDMA\nTransfers a block of data directly to / from memory.\ndevice controller transfers blocks of data from buffer storage directly to main memory without CPU intervention.\nOnly one interrupt is generated per block. The processor is only involved at the beginning and the end of the transfer.\nIO channel\n一个CPU和多个device controller通过总线连接。每个dvice controller可负责多个特定类型设备。\nOS为每个device controller提供一个device driver, driver presents a uniform interface to the device\ncomputer-system architecture single-processor system multiprocessor system / parallel system / tightly coupled 增加吞吐量、规模经济、增加可靠性\ngraceful degradation: 提供与正常工作的硬件成正比服务的能力\nfault tolerant: 超出适度退化的能力 容错\nasymmetric multiprocessing\n主从\neach processor is assigned a specific task. a master processor controls the system, allocates work to the slave processors.\nsymmetric multiprocessing SMP\nmulticore-CPUs\nMultiple compute cores on a single chip 多个内核 单个芯片\nblade servers 刀片服务器\n每个刀片处理器独立启动并运行各自的OS\nclustered system 与多处理器系统不同：多个独立系统耦合\n共享存储并通过LAN/更快内部连接\nasymmetric clustering: one machine is in hot-stand-by mode(热备份)\nsymmetric clustering: monitor each other\nOS structure time-sharing system(multitasking)\ninteractive\nresponse time short\n允许多用户同时共享计算机\nCPU scheduling \u0026amp; multiprogramming : 以提供用户分时计算机的一部分\n为保证合理响应时间，通过swapping得到，使用virtual memory\nOS operations dual mode: user mode \u0026amp; monitor mode\nmode bit provided by hardware\nSome instructions are designated as privileged, only executable in kernel mode.\nSystem call changes mode to kernel mode, return from call resets it to user mode.\n特权指令包括转换到用户模式，IO控制，定时器管理，中断管理等\nprocess management Single-threaded process has one program counter specifying location of next instruction to execute.\nMulti-threaded process has one program counter per thread.\nmemory management determines what is in memory\nCentral to the operation of a modern computer system.  All data should be in memory before and after processing.  All instructions should be in memory in order to execute.\nvirtual memory:\nstorage management file-system management\nAccess control on most systems to determine who can access what.\nmass-storage management\nsecondary storage, tertiary storage\ncaching\ncopying information into faster storage system\ndisk cache\nA portion of main memory used as a buffer to temporarily to hold data for the disk.\ncache memory 高速缓存\ninvisible to OS\ncoherency \u0026amp; consistency\nIO subsystem\nprotection and security protection\n控制进程或用户对计算机系统资源的访问的机制\nsecurity\n防止系统不受外部或内部攻击\naccess control\ninformation flow control\ncertification\n保护和安全需要系统能区分用户，user ID(UID); 需要区分用户集，group ID\nprivilege escalation: 有时用户需要升级特权来获取对一个活动的额外特权\ndistributed systems loosely coupled\nnetwork: communication path TCP/IP协议常用\nnetwork operating system: 更自治 提供信息交换的通信 file sharing, communication, runs independently\n分布式系统更少自治，不同的草作系统紧密连接，好像是一个操作系统控制网络 process migration\nspecial-purpose systems real-time system\nOften used as a control device in a dedicated application\nhard/soft\nreal-time embedded system 实时嵌入式系统\nOS很limited\nmultimedia system 多媒体系统\n将多媒体数据加入到计算机系统(audio and video files)\nhandheld system 手持系统\nPDA: personal digital assistants 专门的嵌入式系统\ncomputing environments traditional computing\nclient-server computing: computer-server, file-server\npeer-to-peer computing: centralized lookupservice, discovery protocol, voice over IP\ncloud computing\nOperating System Concepts 7th edition\nOperating System Concepts 7th edition\nOperating System Concepts 7th\n","date":"2020-02-28T13:00:24Z","permalink":"https://imfaye.me/post/os1/","section":"post","tags":["操作系统","大明湖畔的专业课"],"title":"操作系统笔记 CH1 Intro"},{"categories":["废话"],"contents":"最近很迷茫呢\u0026hellip;\n感觉自己不学无术\u0026hellip;\n夜里12点了，在宿舍床上的电脑桌上敲我的第一篇博客。\n如题，希望是什么的开始。\nTBC\n","date":"2019-09-07T00:23:06Z","permalink":"https://imfaye.me/post/beginning/","section":"post","tags":null,"title":"也许是什么的开始..."},{"categories":null,"contents":"","date":"2019-05-28T00:00:00Z","permalink":"https://imfaye.me/archives/","section":"","tags":null,"title":""}]