<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>大明湖畔的专业课 on Fxye.</title>
    <link>https://bygonexf.github.io/tags/%E5%A4%A7%E6%98%8E%E6%B9%96%E7%95%94%E7%9A%84%E4%B8%93%E4%B8%9A%E8%AF%BE/</link>
    <description>Recent content in 大明湖畔的专业课 on Fxye.</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Faye</copyright>
    <lastBuildDate>Fri, 28 Feb 2020 13:13:24 +0000</lastBuildDate><atom:link href="https://bygonexf.github.io/tags/%E5%A4%A7%E6%98%8E%E6%B9%96%E7%95%94%E7%9A%84%E4%B8%93%E4%B8%9A%E8%AF%BE/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>操作系统笔记 CH13 I/O Systems</title>
      <link>https://bygonexf.github.io/post/os13/</link>
      <pubDate>Fri, 28 Feb 2020 13:13:24 +0000</pubDate>
      
      <guid>https://bygonexf.github.io/post/os13/</guid>
      <description>the kernel is structured to use device-driver modules.
device driver为IO子系统提供了统一设备访问接口
两个趋势：接口日益标准化，设备多样性
IO 硬件 port
bus
controller
Controller usually have registers, where device driver places commands, addresses, and data to write, or read data from registers after command execution. Data-in register, data-out register, status register, control register
设备有地址
Direct I/O instructions
Memory-mapped I/O 内存映射IO
设备控制寄存器 被映射到 处理器的地址空间
Especially for large address spaces (graphics)
IO端口有4种寄存器：
status control data-in data-out Techniques for Performing I/O</description>
    </item>
    
    <item>
      <title>操作系统笔记 CH12 Mass-Storage Structure</title>
      <link>https://bygonexf.github.io/post/os12/</link>
      <pubDate>Fri, 28 Feb 2020 13:12:24 +0000</pubDate>
      
      <guid>https://bygonexf.github.io/post/os12/</guid>
      <description>磁盘 扇区0是最外面柱面的第一个磁道的第一个扇区。映射先按磁道内扇区顺序，再按柱面内磁道顺序，最后按从外到内的柱面顺序来排序的。
Head crash results from disk head making contact with the disk surface. Cannot be repaired, the entire disk must be replaced.
Disks can be removable
Host controller in computer uses bus to talk to disk controller built into drive or storage array.
The disk controller operates the disk-drive hardware to carry out the command.
Disk controllers have a built-in cache. Data transfer at the disk drive happens between the cache and the disk surface.</description>
    </item>
    
    <item>
      <title>操作系统笔记 CH11 File-System Implementation</title>
      <link>https://bygonexf.github.io/post/os11/</link>
      <pubDate>Fri, 28 Feb 2020 13:11:24 +0000</pubDate>
      
      <guid>https://bygonexf.github.io/post/os11/</guid>
      <description>文件系统结构 磁盘特点：可以原地重写，可以直接访问任意一块。
内存和磁盘之间的IO以块为单位。每块为一个或多个扇区。扇区通常为512B
File system resides on secondary storage (disks) OS通过文件系统存储、定位、提取数据
IO control 最底层
由device driver 和 Interrupt handlers组成
实现内存和磁盘之间的信息传输。
device driver可作为翻译器。输入是高层命令，输出是底层的、硬件特定的命令。命令用于控制hardware controller
device driver控制一类设备
basic file system
Issue generic commands to the appropriate device driver to read and write physical blocks on the disk.
file-organization module
将逻辑块地址 转换成 物理块地址
也包括空闲空间管理器
logical file system
管理metadata，元数据包括文件系统所有结构数据，而不包括实际数据
管理目录结构
通过FCB((inodes in UNIX))维护文件结构
负责保护和安全
Layering useful for reducing complexity and redundancy, but adds overhead and can decrease performance.</description>
    </item>
    
    <item>
      <title>操作系统笔记 CH10 File-System Interface</title>
      <link>https://bygonexf.github.io/post/os10/</link>
      <pubDate>Fri, 28 Feb 2020 13:10:24 +0000</pubDate>
      
      <guid>https://bygonexf.github.io/post/os10/</guid>
      <description>file concept 文件：记录在外存上的 相关信息的 具有名称的 集合，逻辑内存的最小分配单元
通常，文件表示程序和数据
free form or may be formatted rigidly
file attributes name: human-readable identifier: a unique number, non-human-readable name type location size protection time, date and user identification 文件的信息存在directory中，directory也存在外存上
A directory entry consists of the file&amp;rsquo;s name and its unique id. The id in turn locates the other file attributes.
file operations 6个基本文件操作：
create
write
write pointer
read
read pointer
A per-process current-file-position pointer
reposition</description>
    </item>
    
    <item>
      <title>操作系统笔记 CH9 Virtual Memory</title>
      <link>https://bygonexf.github.io/post/os9/</link>
      <pubDate>Fri, 28 Feb 2020 13:09:24 +0000</pubDate>
      
      <guid>https://bygonexf.github.io/post/os9/</guid>
      <description>background CH8的内存管理方案需要将整个进程放入内存，动态载入只能减轻这一限制
Code needs to be in memory to execute, but entire program rarely used.
execute partially-loaded program
程序不受现有物理内存大小限制，可以为virtual address space编写程序 更多程序可以同时执行，CPU利用率增加，而响应时间、周转时间不增加 载入或交换程序所需IO变少，用户程序运行更快 Virtual memory – separation of user logical memory from physical memory.
动态内存分配，堆向上增长；子程序调用，栈向下增长。包括洞的虚拟地址空间是稀地址空间。
Enables sparse address spaces with holes left for growth, dynamically linked libraries, etc.
Virtual memory allows files and memory to be shared by two or more processes through page sharing.
虚拟内存实现：
demand paging demand segmentation demand paging 按需调页 Lazy swapper: never swaps a page into memory unless that page will be needed.</description>
    </item>
    
    <item>
      <title>操作系统笔记 CH8 Main Memory</title>
      <link>https://bygonexf.github.io/post/os8/</link>
      <pubDate>Fri, 28 Feb 2020 13:08:24 +0000</pubDate>
      
      <guid>https://bygonexf.github.io/post/os8/</guid>
      <description>background 基本硬件 CPU可直接访问的存储器只有 内存 和 处理器内的寄存器
​	CPU内置寄存器可在一个CPU时钟周期内完成访问，对于寄存器中的内容，CPU可以在一个周期内解析并执行多个指令
​	对于内存，访存可能需要多个时钟周期。没有数据时，要暂停(stall)
协调速度差异，在CPU和内存之间，增加高速缓存cache
instruction-execution cycle: Fetch an instruction, decode instruction, fetch operands, execute, store results back into memory
为了确保正确操作，需要保护内存。
每个进程有独立空间。两个寄存器：
base register: 最小的合法物理地址 limit register: 范围的大小 CPU硬件对user mode产生的每一个地址与寄存器的地址进行比较，实现内存空间的保护。
只有OS可以通过特殊的特权指令加载base register和limit register
地址绑定 address binding 进程在执行时可以在磁盘和内存之间移动，在磁盘上等待调入内存以便执行的进程形成input queue
许多系统允许用户进程放在物理内存的任意位置，用户进程开始地址不必为0
源程序中的地址用符号表示，compiler将symbolic address绑定到relocatable address(如从本模块开始的第14字节)，linker或loader将可重定位地址绑定成absolute address。每次绑定都是从一个地址空间到另一个的映射。
将指令与数据绑定到内存地址有几种情况：
compile time
编译时就知道进程将在内存中的驻留地址，可以生成absolute code
如果将来地址发生变化，必须重新编译代码
load time
编译时不知道。编译器生成relocatable code
绑定延迟到加载时
如果开始地址发生变化，只需重新加载用户代码引入改变值
execution time
进程在执行时可以从一个内存段移到另一个内存段
绑定延迟到执行时
需要硬件(如base and limit registers)
logical vs.</description>
    </item>
    
    <item>
      <title>操作系统笔记 CH7 Deadlocks</title>
      <link>https://bygonexf.github.io/post/os7/</link>
      <pubDate>Fri, 28 Feb 2020 13:07:24 +0000</pubDate>
      
      <guid>https://bygonexf.github.io/post/os7/</guid>
      <description>deadlock characteristics necessary conditions 4个条件同时满足，引起死锁：
mutual exclusion
至少有一个资源处于非共享模式，一次只能有一个进程使用
hold and wait
占有至少一个资源，等待另一为其他进程所占资源
no preemption
资源不能被抢占
circular wait
resource-allocation graph request edge : Pi-&amp;gt;Rj
assignment edge : Rj-&amp;gt;Pi
申请边只用指向矩形，但分配边必须从某个原点开始
资源分配图有环是死锁的必要条件。若每类资源只有一个实例，含环是充分必要条件。若同类资源数&amp;gt;1,不一定有死锁。
methods for handling deadlocks 1.预防或避免死锁
2.允许进入死锁，检测并恢复
3.忽视这个问题(为多数OS所用)
deadlock prevention: 确保至少一个必要条件不成立，通过限制如何申请资源
deadlock avoidance: 事先得到进程申请和使用资源的额外信息，系统可确定对于一个申请，进程是否等待(申请允许还是延迟)，考虑可用、已分配、进程将来申请和释放的资源
deadlock prevention 确保4个必要条件至少1个不成立
mutual exclusion
通常不通过这个条件&amp;hellip;
hold and wait
每个进程在执行前申请并获得所有资源
进程在没有资源时才可申请资源(申请更多资源前，先释放已分配的资源)
缺点:1.资源利用率低 2.starvation
no preemption
如果一个进程占有资源并申请另一个不能立即分配的资源，其现在已分配的资源都可被抢占(被隐式释放)。
进程申请资源时，不可用也不被其他等待进程占有时，等待
常应用于状态可以保存恢复的资源，如CPU寄存器和内存，不适用于打印机和磁带驱动器等。
circular wait
对所有资源类型进行完全排序。每个进程只按递增顺序申请资源。(只能申请编号比它大的)
deadlock avoidance 死锁避免比死锁预防要求低
deadlock prevention 低设备使用率和吞吐率
a system is in a safe state only if there exists a safe sequence</description>
    </item>
    
    <item>
      <title>操作系统笔记 CH6 Process Synchronization</title>
      <link>https://bygonexf.github.io/post/os6/</link>
      <pubDate>Fri, 28 Feb 2020 13:06:24 +0000</pubDate>
      
      <guid>https://bygonexf.github.io/post/os6/</guid>
      <description>race condition: 多个进程并发访问和操作同一数据，结果与访问顺序有关
critical section critical section: 进程可能改变共同变量，更新表，写文件的代码段
entry section: 实现请求进入其临界区的代码段
临界区问题三要求：
mutual exclusion 同一时间临界区存在一个进程 progress 如果一个进程想进入临界区，它终将成功 bounded waiting 从一个进程做出进入临界区的请求，到该请求被允许，其他进程允许进入临界区的次数有限 kernel code可能会出现race condition
两种方法: 1.preemptive kernel 2.non-preemptive kernel 抢占内核更适合real-time programming,且更responsive
Peterson&amp;rsquo;s solution software-based solution to the critical section problem 基于软件
synchronization hardware 基于硬件
特殊硬件指令 原子地(不可中断)检查、修改、交换字内容
disable interrupt, a lock
TestAndSet()
返回的是原来的值，进入过testandset，之后就变成true
实现有限等待互斥：</description>
    </item>
    
    <item>
      <title>操作系统笔记 CH5 CPU Scheduling</title>
      <link>https://bygonexf.github.io/post/os5/</link>
      <pubDate>Fri, 28 Feb 2020 13:05:24 +0000</pubDate>
      
      <guid>https://bygonexf.github.io/post/os5/</guid>
      <description>dispatcher: gives control of the CPU to the process selected by the short-term scheduler;
dispatch latency
scheduling criteria CPU utilization,
throughput:
单位时间完成进程数量
turnaround time:
submission to completion
waiting time:
sum of time spent in the ready queue就绪队列
response time:
submission to first response(time it takes to start responding, not the time it takes to output the response)
scheduling algorithm FCFS first-come, first-served
non-preemptive
等待时间较长
convoy effect(短进程跟在长进程后面)
SJF shortest-job-first
shortest next CPU burst</description>
    </item>
    
    <item>
      <title>操作系统笔记 CH4 Threads</title>
      <link>https://bygonexf.github.io/post/os4/</link>
      <pubDate>Fri, 28 Feb 2020 13:04:24 +0000</pubDate>
      
      <guid>https://bygonexf.github.io/post/os4/</guid>
      <description>Dispatching is referred to as a thread. Resource of ownership is referred to as a process or task.
对进程的swapping和termination都牵扯它所有线程
线程是CPU使用的基本单位。由thread ID, program counter, register set, stack组成
multithreading models User threads, supported above the kernel and are managed without kernel support.
Kernel threads, supported and managed directly by the operating system.
many-to-one
one-to-one
一个线程阻塞，另一个还能运行
并发。开销大。
windows, linux, solaris 9
many-to-many
用户线程映射到数量相同或更少的内核线程
When a thread performs a blocking system call, the kernel can schedule another thread for execution.</description>
    </item>
    
    <item>
      <title>操作系统笔记 CH3 Process</title>
      <link>https://bygonexf.github.io/post/os3/</link>
      <pubDate>Fri, 28 Feb 2020 13:03:24 +0000</pubDate>
      
      <guid>https://bygonexf.github.io/post/os3/</guid>
      <description>process concepts batch system: job; time-sharing system: program/task
Program is passive entity stored on disk (executable file), process is active.
a process includes
text section(program code) data section(global variables) heap(动态分配的内存) process stack(临时数据) function parameters, return value return addresses local variables current activity(represented by program counter and registers) process state
new: being created running: instructions are being executed waiting/limiting: waiting for some event ready: waiting to be assigned to a processor terminated/halted: finished execution 一次只有一个进程可以在一个处理器上运行，但多个进程可处于就绪或等待状态。</description>
    </item>
    
    <item>
      <title>操作系统笔记 CH2 OS structures</title>
      <link>https://bygonexf.github.io/post/os2/</link>
      <pubDate>Fri, 28 Feb 2020 13:01:24 +0000</pubDate>
      
      <guid>https://bygonexf.github.io/post/os2/</guid>
      <description>UI CLI command-line / command interpreter
implemented in kernel (MS-DOS)
by systems program (Windows / UNIX)
multiple flavors implemented – shells UNIX / Linux
linux shell : shell: 带形参的批命令文件
batch interface
GUI graphical user interface
desktop, icon, Xerox PARC
system calls Programming interface to the services provided by the OS
written in high-level language
Mostly accessed by programs via a high-level Application Program Interface (API) rather than direct system call use.</description>
    </item>
    
    <item>
      <title>操作系统笔记 CH1 Intro</title>
      <link>https://bygonexf.github.io/post/os1/</link>
      <pubDate>Fri, 28 Feb 2020 13:00:24 +0000</pubDate>
      
      <guid>https://bygonexf.github.io/post/os1/</guid>
      <description>What OS do 操作系统是管理计算机硬件的程序
computer system: hardware, operating system, application programs, users
​	hardware: CPU, memory, I/O devices
user view services provided by OS:
program development (editors and debuggers)
program execution
access to IO devices
controlled access to files
system access
error detection and response
internal and external hardware errors
memory error, device failure
software errors
arithmetic overflow, accesss forbidden memory locations
外中断: interruption 与当前运行程序无关的事件
内中断: exception / trap 非法操作码，地址越界，算术溢出，缺页，专门陷入指令&amp;hellip;</description>
    </item>
    
  </channel>
</rss>
